// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef PROTOBUF_messages_2eproto__INCLUDED
#define PROTOBUF_messages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace lms {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_messages_2eproto();
void protobuf_AssignDesc_messages_2eproto();
void protobuf_ShutdownFile_messages_2eproto();

class Request;
class Request_Info;
class Request_Shutdown;
class Request_ListClients;
class Request_Run;
class Request_ListProcesses;
class Request_Attach;
class Request_Stop;
class Request_ModuleList;
class Request_Profiling;
class Response;
class Response_Info;
class Response_ClientList;
class Response_ClientList_Client;
class Response_ProcessList;
class Response_ProcessList_Process;
class Response_ModuleListResponse;
class Response_ModuleListResponse_Access;
class Response_ModuleListResponse_Channel;
class Response_LogEvent;
class Response_ProfilingSummary;
class Response_ProfilingSummary_Trace;

enum Response_ModuleListResponse_Permission {
  Response_ModuleListResponse_Permission_READ = 1,
  Response_ModuleListResponse_Permission_WRITE = 2
};
bool Response_ModuleListResponse_Permission_IsValid(int value);
const Response_ModuleListResponse_Permission Response_ModuleListResponse_Permission_Permission_MIN = Response_ModuleListResponse_Permission_READ;
const Response_ModuleListResponse_Permission Response_ModuleListResponse_Permission_Permission_MAX = Response_ModuleListResponse_Permission_WRITE;
const int Response_ModuleListResponse_Permission_Permission_ARRAYSIZE = Response_ModuleListResponse_Permission_Permission_MAX + 1;

const ::google::protobuf::EnumDescriptor* Response_ModuleListResponse_Permission_descriptor();
inline const ::std::string& Response_ModuleListResponse_Permission_Name(Response_ModuleListResponse_Permission value) {
  return ::google::protobuf::internal::NameOfEnum(
    Response_ModuleListResponse_Permission_descriptor(), value);
}
inline bool Response_ModuleListResponse_Permission_Parse(
    const ::std::string& name, Response_ModuleListResponse_Permission* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Response_ModuleListResponse_Permission>(
    Response_ModuleListResponse_Permission_descriptor(), name, value);
}
enum Response_LogEvent_Level {
  Response_LogEvent_Level_ALL = 0,
  Response_LogEvent_Level_PROFILE = 10,
  Response_LogEvent_Level_DEBUG = 20,
  Response_LogEvent_Level_INFO = 30,
  Response_LogEvent_Level_WARN = 40,
  Response_LogEvent_Level_ERROR = 50,
  Response_LogEvent_Level_OFF = 255
};
bool Response_LogEvent_Level_IsValid(int value);
const Response_LogEvent_Level Response_LogEvent_Level_Level_MIN = Response_LogEvent_Level_ALL;
const Response_LogEvent_Level Response_LogEvent_Level_Level_MAX = Response_LogEvent_Level_OFF;
const int Response_LogEvent_Level_Level_ARRAYSIZE = Response_LogEvent_Level_Level_MAX + 1;

const ::google::protobuf::EnumDescriptor* Response_LogEvent_Level_descriptor();
inline const ::std::string& Response_LogEvent_Level_Name(Response_LogEvent_Level value) {
  return ::google::protobuf::internal::NameOfEnum(
    Response_LogEvent_Level_descriptor(), value);
}
inline bool Response_LogEvent_Level_Parse(
    const ::std::string& name, Response_LogEvent_Level* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Response_LogEvent_Level>(
    Response_LogEvent_Level_descriptor(), name, value);
}
// ===================================================================

class Request_Info : public ::google::protobuf::Message {
 public:
  Request_Info();
  virtual ~Request_Info();

  Request_Info(const Request_Info& from);

  inline Request_Info& operator=(const Request_Info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_Info& default_instance();

  void Swap(Request_Info* other);

  // implements Message ----------------------------------------------

  Request_Info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_Info& from);
  void MergeFrom(const Request_Info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:lms.Request.Info)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_Info* default_instance_;
};
// -------------------------------------------------------------------

class Request_Shutdown : public ::google::protobuf::Message {
 public:
  Request_Shutdown();
  virtual ~Request_Shutdown();

  Request_Shutdown(const Request_Shutdown& from);

  inline Request_Shutdown& operator=(const Request_Shutdown& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_Shutdown& default_instance();

  void Swap(Request_Shutdown* other);

  // implements Message ----------------------------------------------

  Request_Shutdown* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_Shutdown& from);
  void MergeFrom(const Request_Shutdown& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:lms.Request.Shutdown)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_Shutdown* default_instance_;
};
// -------------------------------------------------------------------

class Request_ListClients : public ::google::protobuf::Message {
 public:
  Request_ListClients();
  virtual ~Request_ListClients();

  Request_ListClients(const Request_ListClients& from);

  inline Request_ListClients& operator=(const Request_ListClients& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_ListClients& default_instance();

  void Swap(Request_ListClients* other);

  // implements Message ----------------------------------------------

  Request_ListClients* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_ListClients& from);
  void MergeFrom(const Request_ListClients& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:lms.Request.ListClients)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_ListClients* default_instance_;
};
// -------------------------------------------------------------------

class Request_Run : public ::google::protobuf::Message {
 public:
  Request_Run();
  virtual ~Request_Run();

  Request_Run(const Request_Run& from);

  inline Request_Run& operator=(const Request_Run& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_Run& default_instance();

  void Swap(Request_Run* other);

  // implements Message ----------------------------------------------

  Request_Run* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_Run& from);
  void MergeFrom(const Request_Run& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string config_file = 1;
  inline bool has_config_file() const;
  inline void clear_config_file();
  static const int kConfigFileFieldNumber = 1;
  inline const ::std::string& config_file() const;
  inline void set_config_file(const ::std::string& value);
  inline void set_config_file(const char* value);
  inline void set_config_file(const char* value, size_t size);
  inline ::std::string* mutable_config_file();
  inline ::std::string* release_config_file();
  inline void set_allocated_config_file(::std::string* config_file);

  // repeated string include_paths = 2;
  inline int include_paths_size() const;
  inline void clear_include_paths();
  static const int kIncludePathsFieldNumber = 2;
  inline const ::std::string& include_paths(int index) const;
  inline ::std::string* mutable_include_paths(int index);
  inline void set_include_paths(int index, const ::std::string& value);
  inline void set_include_paths(int index, const char* value);
  inline void set_include_paths(int index, const char* value, size_t size);
  inline ::std::string* add_include_paths();
  inline void add_include_paths(const ::std::string& value);
  inline void add_include_paths(const char* value);
  inline void add_include_paths(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& include_paths() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_include_paths();

  // repeated string flags = 3;
  inline int flags_size() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 3;
  inline const ::std::string& flags(int index) const;
  inline ::std::string* mutable_flags(int index);
  inline void set_flags(int index, const ::std::string& value);
  inline void set_flags(int index, const char* value);
  inline void set_flags(int index, const char* value, size_t size);
  inline ::std::string* add_flags();
  inline void add_flags(const ::std::string& value);
  inline void add_flags(const char* value);
  inline void add_flags(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& flags() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_flags();

  // optional bool debug = 4;
  inline bool has_debug() const;
  inline void clear_debug();
  static const int kDebugFieldNumber = 4;
  inline bool debug() const;
  inline void set_debug(bool value);

  // optional bool detached = 5 [default = false];
  inline bool has_detached() const;
  inline void clear_detached();
  static const int kDetachedFieldNumber = 5;
  inline bool detached() const;
  inline void set_detached(bool value);

  // optional bool shutdown_runtime_on_detach = 6 [default = false];
  inline bool has_shutdown_runtime_on_detach() const;
  inline void clear_shutdown_runtime_on_detach();
  static const int kShutdownRuntimeOnDetachFieldNumber = 6;
  inline bool shutdown_runtime_on_detach() const;
  inline void set_shutdown_runtime_on_detach(bool value);

  // @@protoc_insertion_point(class_scope:lms.Request.Run)
 private:
  inline void set_has_config_file();
  inline void clear_has_config_file();
  inline void set_has_debug();
  inline void clear_has_debug();
  inline void set_has_detached();
  inline void clear_has_detached();
  inline void set_has_shutdown_runtime_on_detach();
  inline void clear_has_shutdown_runtime_on_detach();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* config_file_;
  ::google::protobuf::RepeatedPtrField< ::std::string> include_paths_;
  ::google::protobuf::RepeatedPtrField< ::std::string> flags_;
  bool debug_;
  bool detached_;
  bool shutdown_runtime_on_detach_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_Run* default_instance_;
};
// -------------------------------------------------------------------

class Request_ListProcesses : public ::google::protobuf::Message {
 public:
  Request_ListProcesses();
  virtual ~Request_ListProcesses();

  Request_ListProcesses(const Request_ListProcesses& from);

  inline Request_ListProcesses& operator=(const Request_ListProcesses& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_ListProcesses& default_instance();

  void Swap(Request_ListProcesses* other);

  // implements Message ----------------------------------------------

  Request_ListProcesses* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_ListProcesses& from);
  void MergeFrom(const Request_ListProcesses& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:lms.Request.ListProcesses)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_ListProcesses* default_instance_;
};
// -------------------------------------------------------------------

class Request_Attach : public ::google::protobuf::Message {
 public:
  Request_Attach();
  virtual ~Request_Attach();

  Request_Attach(const Request_Attach& from);

  inline Request_Attach& operator=(const Request_Attach& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_Attach& default_instance();

  void Swap(Request_Attach* other);

  // implements Message ----------------------------------------------

  Request_Attach* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_Attach& from);
  void MergeFrom(const Request_Attach& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:lms.Request.Attach)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_Attach* default_instance_;
};
// -------------------------------------------------------------------

class Request_Stop : public ::google::protobuf::Message {
 public:
  Request_Stop();
  virtual ~Request_Stop();

  Request_Stop(const Request_Stop& from);

  inline Request_Stop& operator=(const Request_Stop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_Stop& default_instance();

  void Swap(Request_Stop* other);

  // implements Message ----------------------------------------------

  Request_Stop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_Stop& from);
  void MergeFrom(const Request_Stop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional bool kill = 2;
  inline bool has_kill() const;
  inline void clear_kill();
  static const int kKillFieldNumber = 2;
  inline bool kill() const;
  inline void set_kill(bool value);

  // @@protoc_insertion_point(class_scope:lms.Request.Stop)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_kill();
  inline void clear_has_kill();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  bool kill_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_Stop* default_instance_;
};
// -------------------------------------------------------------------

class Request_ModuleList : public ::google::protobuf::Message {
 public:
  Request_ModuleList();
  virtual ~Request_ModuleList();

  Request_ModuleList(const Request_ModuleList& from);

  inline Request_ModuleList& operator=(const Request_ModuleList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_ModuleList& default_instance();

  void Swap(Request_ModuleList* other);

  // implements Message ----------------------------------------------

  Request_ModuleList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_ModuleList& from);
  void MergeFrom(const Request_ModuleList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:lms.Request.ModuleList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_ModuleList* default_instance_;
};
// -------------------------------------------------------------------

class Request_Profiling : public ::google::protobuf::Message {
 public:
  Request_Profiling();
  virtual ~Request_Profiling();

  Request_Profiling(const Request_Profiling& from);

  inline Request_Profiling& operator=(const Request_Profiling& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_Profiling& default_instance();

  void Swap(Request_Profiling* other);

  // implements Message ----------------------------------------------

  Request_Profiling* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_Profiling& from);
  void MergeFrom(const Request_Profiling& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:lms.Request.Profiling)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_Profiling* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  enum ContentCase {
    kInfo = 1,
    kShutdown = 2,
    kListClients = 3,
    kRun = 4,
    kListProcesses = 5,
    kAttach = 6,
    kStop = 7,
    kModuleList = 8,
    kProfiling = 9,
    CONTENT_NOT_SET = 0,
  };

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Request_Info Info;
  typedef Request_Shutdown Shutdown;
  typedef Request_ListClients ListClients;
  typedef Request_Run Run;
  typedef Request_ListProcesses ListProcesses;
  typedef Request_Attach Attach;
  typedef Request_Stop Stop;
  typedef Request_ModuleList ModuleList;
  typedef Request_Profiling Profiling;

  // accessors -------------------------------------------------------

  // optional .lms.Request.Info info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::lms::Request_Info& info() const;
  inline ::lms::Request_Info* mutable_info();
  inline ::lms::Request_Info* release_info();
  inline void set_allocated_info(::lms::Request_Info* info);

  // optional .lms.Request.Shutdown shutdown = 2;
  inline bool has_shutdown() const;
  inline void clear_shutdown();
  static const int kShutdownFieldNumber = 2;
  inline const ::lms::Request_Shutdown& shutdown() const;
  inline ::lms::Request_Shutdown* mutable_shutdown();
  inline ::lms::Request_Shutdown* release_shutdown();
  inline void set_allocated_shutdown(::lms::Request_Shutdown* shutdown);

  // optional .lms.Request.ListClients list_clients = 3;
  inline bool has_list_clients() const;
  inline void clear_list_clients();
  static const int kListClientsFieldNumber = 3;
  inline const ::lms::Request_ListClients& list_clients() const;
  inline ::lms::Request_ListClients* mutable_list_clients();
  inline ::lms::Request_ListClients* release_list_clients();
  inline void set_allocated_list_clients(::lms::Request_ListClients* list_clients);

  // optional .lms.Request.Run run = 4;
  inline bool has_run() const;
  inline void clear_run();
  static const int kRunFieldNumber = 4;
  inline const ::lms::Request_Run& run() const;
  inline ::lms::Request_Run* mutable_run();
  inline ::lms::Request_Run* release_run();
  inline void set_allocated_run(::lms::Request_Run* run);

  // optional .lms.Request.ListProcesses list_processes = 5;
  inline bool has_list_processes() const;
  inline void clear_list_processes();
  static const int kListProcessesFieldNumber = 5;
  inline const ::lms::Request_ListProcesses& list_processes() const;
  inline ::lms::Request_ListProcesses* mutable_list_processes();
  inline ::lms::Request_ListProcesses* release_list_processes();
  inline void set_allocated_list_processes(::lms::Request_ListProcesses* list_processes);

  // optional .lms.Request.Attach attach = 6;
  inline bool has_attach() const;
  inline void clear_attach();
  static const int kAttachFieldNumber = 6;
  inline const ::lms::Request_Attach& attach() const;
  inline ::lms::Request_Attach* mutable_attach();
  inline ::lms::Request_Attach* release_attach();
  inline void set_allocated_attach(::lms::Request_Attach* attach);

  // optional .lms.Request.Stop stop = 7;
  inline bool has_stop() const;
  inline void clear_stop();
  static const int kStopFieldNumber = 7;
  inline const ::lms::Request_Stop& stop() const;
  inline ::lms::Request_Stop* mutable_stop();
  inline ::lms::Request_Stop* release_stop();
  inline void set_allocated_stop(::lms::Request_Stop* stop);

  // optional .lms.Request.ModuleList module_list = 8;
  inline bool has_module_list() const;
  inline void clear_module_list();
  static const int kModuleListFieldNumber = 8;
  inline const ::lms::Request_ModuleList& module_list() const;
  inline ::lms::Request_ModuleList* mutable_module_list();
  inline ::lms::Request_ModuleList* release_module_list();
  inline void set_allocated_module_list(::lms::Request_ModuleList* module_list);

  // optional .lms.Request.Profiling profiling = 9;
  inline bool has_profiling() const;
  inline void clear_profiling();
  static const int kProfilingFieldNumber = 9;
  inline const ::lms::Request_Profiling& profiling() const;
  inline ::lms::Request_Profiling* mutable_profiling();
  inline ::lms::Request_Profiling* release_profiling();
  inline void set_allocated_profiling(::lms::Request_Profiling* profiling);

  inline ContentCase content_case() const;
  // @@protoc_insertion_point(class_scope:lms.Request)
 private:
  inline void set_has_info();
  inline void set_has_shutdown();
  inline void set_has_list_clients();
  inline void set_has_run();
  inline void set_has_list_processes();
  inline void set_has_attach();
  inline void set_has_stop();
  inline void set_has_module_list();
  inline void set_has_profiling();

  inline bool has_content();
  void clear_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union ContentUnion {
    ::lms::Request_Info* info_;
    ::lms::Request_Shutdown* shutdown_;
    ::lms::Request_ListClients* list_clients_;
    ::lms::Request_Run* run_;
    ::lms::Request_ListProcesses* list_processes_;
    ::lms::Request_Attach* attach_;
    ::lms::Request_Stop* stop_;
    ::lms::Request_ModuleList* module_list_;
    ::lms::Request_Profiling* profiling_;
  } content_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Response_Info : public ::google::protobuf::Message {
 public:
  Response_Info();
  virtual ~Response_Info();

  Response_Info(const Response_Info& from);

  inline Response_Info& operator=(const Response_Info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_Info& default_instance();

  void Swap(Response_Info* other);

  // implements Message ----------------------------------------------

  Response_Info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_Info& from);
  void MergeFrom(const Response_Info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // optional int32 pid = 2;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 2;
  inline ::google::protobuf::int32 pid() const;
  inline void set_pid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:lms.Response.Info)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_pid();
  inline void clear_has_pid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 version_;
  ::google::protobuf::int32 pid_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_Info* default_instance_;
};
// -------------------------------------------------------------------

class Response_ClientList_Client : public ::google::protobuf::Message {
 public:
  Response_ClientList_Client();
  virtual ~Response_ClientList_Client();

  Response_ClientList_Client(const Response_ClientList_Client& from);

  inline Response_ClientList_Client& operator=(const Response_ClientList_Client& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_ClientList_Client& default_instance();

  void Swap(Response_ClientList_Client* other);

  // implements Message ----------------------------------------------

  Response_ClientList_Client* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_ClientList_Client& from);
  void MergeFrom(const Response_ClientList_Client& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 fd = 1;
  inline bool has_fd() const;
  inline void clear_fd();
  static const int kFdFieldNumber = 1;
  inline ::google::protobuf::int32 fd() const;
  inline void set_fd(::google::protobuf::int32 value);

  // optional string peer = 2;
  inline bool has_peer() const;
  inline void clear_peer();
  static const int kPeerFieldNumber = 2;
  inline const ::std::string& peer() const;
  inline void set_peer(const ::std::string& value);
  inline void set_peer(const char* value);
  inline void set_peer(const char* value, size_t size);
  inline ::std::string* mutable_peer();
  inline ::std::string* release_peer();
  inline void set_allocated_peer(::std::string* peer);

  // @@protoc_insertion_point(class_scope:lms.Response.ClientList.Client)
 private:
  inline void set_has_fd();
  inline void clear_has_fd();
  inline void set_has_peer();
  inline void clear_has_peer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* peer_;
  ::google::protobuf::int32 fd_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_ClientList_Client* default_instance_;
};
// -------------------------------------------------------------------

class Response_ClientList : public ::google::protobuf::Message {
 public:
  Response_ClientList();
  virtual ~Response_ClientList();

  Response_ClientList(const Response_ClientList& from);

  inline Response_ClientList& operator=(const Response_ClientList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_ClientList& default_instance();

  void Swap(Response_ClientList* other);

  // implements Message ----------------------------------------------

  Response_ClientList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_ClientList& from);
  void MergeFrom(const Response_ClientList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Response_ClientList_Client Client;

  // accessors -------------------------------------------------------

  // repeated .lms.Response.ClientList.Client clients = 1;
  inline int clients_size() const;
  inline void clear_clients();
  static const int kClientsFieldNumber = 1;
  inline const ::lms::Response_ClientList_Client& clients(int index) const;
  inline ::lms::Response_ClientList_Client* mutable_clients(int index);
  inline ::lms::Response_ClientList_Client* add_clients();
  inline const ::google::protobuf::RepeatedPtrField< ::lms::Response_ClientList_Client >&
      clients() const;
  inline ::google::protobuf::RepeatedPtrField< ::lms::Response_ClientList_Client >*
      mutable_clients();

  // @@protoc_insertion_point(class_scope:lms.Response.ClientList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::lms::Response_ClientList_Client > clients_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_ClientList* default_instance_;
};
// -------------------------------------------------------------------

class Response_ProcessList_Process : public ::google::protobuf::Message {
 public:
  Response_ProcessList_Process();
  virtual ~Response_ProcessList_Process();

  Response_ProcessList_Process(const Response_ProcessList_Process& from);

  inline Response_ProcessList_Process& operator=(const Response_ProcessList_Process& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_ProcessList_Process& default_instance();

  void Swap(Response_ProcessList_Process* other);

  // implements Message ----------------------------------------------

  Response_ProcessList_Process* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_ProcessList_Process& from);
  void MergeFrom(const Response_ProcessList_Process& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 pid = 1;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 1;
  inline ::google::protobuf::int32 pid() const;
  inline void set_pid(::google::protobuf::int32 value);

  // optional string config_file = 2;
  inline bool has_config_file() const;
  inline void clear_config_file();
  static const int kConfigFileFieldNumber = 2;
  inline const ::std::string& config_file() const;
  inline void set_config_file(const ::std::string& value);
  inline void set_config_file(const char* value);
  inline void set_config_file(const char* value, size_t size);
  inline ::std::string* mutable_config_file();
  inline ::std::string* release_config_file();
  inline void set_allocated_config_file(::std::string* config_file);

  // @@protoc_insertion_point(class_scope:lms.Response.ProcessList.Process)
 private:
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_config_file();
  inline void clear_has_config_file();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* config_file_;
  ::google::protobuf::int32 pid_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_ProcessList_Process* default_instance_;
};
// -------------------------------------------------------------------

class Response_ProcessList : public ::google::protobuf::Message {
 public:
  Response_ProcessList();
  virtual ~Response_ProcessList();

  Response_ProcessList(const Response_ProcessList& from);

  inline Response_ProcessList& operator=(const Response_ProcessList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_ProcessList& default_instance();

  void Swap(Response_ProcessList* other);

  // implements Message ----------------------------------------------

  Response_ProcessList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_ProcessList& from);
  void MergeFrom(const Response_ProcessList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Response_ProcessList_Process Process;

  // accessors -------------------------------------------------------

  // repeated .lms.Response.ProcessList.Process processes = 1;
  inline int processes_size() const;
  inline void clear_processes();
  static const int kProcessesFieldNumber = 1;
  inline const ::lms::Response_ProcessList_Process& processes(int index) const;
  inline ::lms::Response_ProcessList_Process* mutable_processes(int index);
  inline ::lms::Response_ProcessList_Process* add_processes();
  inline const ::google::protobuf::RepeatedPtrField< ::lms::Response_ProcessList_Process >&
      processes() const;
  inline ::google::protobuf::RepeatedPtrField< ::lms::Response_ProcessList_Process >*
      mutable_processes();

  // @@protoc_insertion_point(class_scope:lms.Response.ProcessList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::lms::Response_ProcessList_Process > processes_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_ProcessList* default_instance_;
};
// -------------------------------------------------------------------

class Response_ModuleListResponse_Access : public ::google::protobuf::Message {
 public:
  Response_ModuleListResponse_Access();
  virtual ~Response_ModuleListResponse_Access();

  Response_ModuleListResponse_Access(const Response_ModuleListResponse_Access& from);

  inline Response_ModuleListResponse_Access& operator=(const Response_ModuleListResponse_Access& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_ModuleListResponse_Access& default_instance();

  void Swap(Response_ModuleListResponse_Access* other);

  // implements Message ----------------------------------------------

  Response_ModuleListResponse_Access* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_ModuleListResponse_Access& from);
  void MergeFrom(const Response_ModuleListResponse_Access& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string module = 1;
  inline bool has_module() const;
  inline void clear_module();
  static const int kModuleFieldNumber = 1;
  inline const ::std::string& module() const;
  inline void set_module(const ::std::string& value);
  inline void set_module(const char* value);
  inline void set_module(const char* value, size_t size);
  inline ::std::string* mutable_module();
  inline ::std::string* release_module();
  inline void set_allocated_module(::std::string* module);

  // optional .lms.Response.ModuleListResponse.Permission permission = 2;
  inline bool has_permission() const;
  inline void clear_permission();
  static const int kPermissionFieldNumber = 2;
  inline ::lms::Response_ModuleListResponse_Permission permission() const;
  inline void set_permission(::lms::Response_ModuleListResponse_Permission value);

  // optional int32 priority = 3;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 3;
  inline ::google::protobuf::int32 priority() const;
  inline void set_priority(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:lms.Response.ModuleListResponse.Access)
 private:
  inline void set_has_module();
  inline void clear_has_module();
  inline void set_has_permission();
  inline void clear_has_permission();
  inline void set_has_priority();
  inline void clear_has_priority();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* module_;
  int permission_;
  ::google::protobuf::int32 priority_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_ModuleListResponse_Access* default_instance_;
};
// -------------------------------------------------------------------

class Response_ModuleListResponse_Channel : public ::google::protobuf::Message {
 public:
  Response_ModuleListResponse_Channel();
  virtual ~Response_ModuleListResponse_Channel();

  Response_ModuleListResponse_Channel(const Response_ModuleListResponse_Channel& from);

  inline Response_ModuleListResponse_Channel& operator=(const Response_ModuleListResponse_Channel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_ModuleListResponse_Channel& default_instance();

  void Swap(Response_ModuleListResponse_Channel* other);

  // implements Message ----------------------------------------------

  Response_ModuleListResponse_Channel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_ModuleListResponse_Channel& from);
  void MergeFrom(const Response_ModuleListResponse_Channel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .lms.Response.ModuleListResponse.Access access_list = 2;
  inline int access_list_size() const;
  inline void clear_access_list();
  static const int kAccessListFieldNumber = 2;
  inline const ::lms::Response_ModuleListResponse_Access& access_list(int index) const;
  inline ::lms::Response_ModuleListResponse_Access* mutable_access_list(int index);
  inline ::lms::Response_ModuleListResponse_Access* add_access_list();
  inline const ::google::protobuf::RepeatedPtrField< ::lms::Response_ModuleListResponse_Access >&
      access_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::lms::Response_ModuleListResponse_Access >*
      mutable_access_list();

  // @@protoc_insertion_point(class_scope:lms.Response.ModuleListResponse.Channel)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::lms::Response_ModuleListResponse_Access > access_list_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_ModuleListResponse_Channel* default_instance_;
};
// -------------------------------------------------------------------

class Response_ModuleListResponse : public ::google::protobuf::Message {
 public:
  Response_ModuleListResponse();
  virtual ~Response_ModuleListResponse();

  Response_ModuleListResponse(const Response_ModuleListResponse& from);

  inline Response_ModuleListResponse& operator=(const Response_ModuleListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_ModuleListResponse& default_instance();

  void Swap(Response_ModuleListResponse* other);

  // implements Message ----------------------------------------------

  Response_ModuleListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_ModuleListResponse& from);
  void MergeFrom(const Response_ModuleListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Response_ModuleListResponse_Access Access;
  typedef Response_ModuleListResponse_Channel Channel;

  typedef Response_ModuleListResponse_Permission Permission;
  static const Permission READ = Response_ModuleListResponse_Permission_READ;
  static const Permission WRITE = Response_ModuleListResponse_Permission_WRITE;
  static inline bool Permission_IsValid(int value) {
    return Response_ModuleListResponse_Permission_IsValid(value);
  }
  static const Permission Permission_MIN =
    Response_ModuleListResponse_Permission_Permission_MIN;
  static const Permission Permission_MAX =
    Response_ModuleListResponse_Permission_Permission_MAX;
  static const int Permission_ARRAYSIZE =
    Response_ModuleListResponse_Permission_Permission_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Permission_descriptor() {
    return Response_ModuleListResponse_Permission_descriptor();
  }
  static inline const ::std::string& Permission_Name(Permission value) {
    return Response_ModuleListResponse_Permission_Name(value);
  }
  static inline bool Permission_Parse(const ::std::string& name,
      Permission* value) {
    return Response_ModuleListResponse_Permission_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .lms.Response.ModuleListResponse.Channel channels = 1;
  inline int channels_size() const;
  inline void clear_channels();
  static const int kChannelsFieldNumber = 1;
  inline const ::lms::Response_ModuleListResponse_Channel& channels(int index) const;
  inline ::lms::Response_ModuleListResponse_Channel* mutable_channels(int index);
  inline ::lms::Response_ModuleListResponse_Channel* add_channels();
  inline const ::google::protobuf::RepeatedPtrField< ::lms::Response_ModuleListResponse_Channel >&
      channels() const;
  inline ::google::protobuf::RepeatedPtrField< ::lms::Response_ModuleListResponse_Channel >*
      mutable_channels();

  // @@protoc_insertion_point(class_scope:lms.Response.ModuleListResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::lms::Response_ModuleListResponse_Channel > channels_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_ModuleListResponse* default_instance_;
};
// -------------------------------------------------------------------

class Response_LogEvent : public ::google::protobuf::Message {
 public:
  Response_LogEvent();
  virtual ~Response_LogEvent();

  Response_LogEvent(const Response_LogEvent& from);

  inline Response_LogEvent& operator=(const Response_LogEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_LogEvent& default_instance();

  void Swap(Response_LogEvent* other);

  // implements Message ----------------------------------------------

  Response_LogEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_LogEvent& from);
  void MergeFrom(const Response_LogEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Response_LogEvent_Level Level;
  static const Level ALL = Response_LogEvent_Level_ALL;
  static const Level PROFILE = Response_LogEvent_Level_PROFILE;
  static const Level DEBUG = Response_LogEvent_Level_DEBUG;
  static const Level INFO = Response_LogEvent_Level_INFO;
  static const Level WARN = Response_LogEvent_Level_WARN;
  static const Level ERROR = Response_LogEvent_Level_ERROR;
  static const Level OFF = Response_LogEvent_Level_OFF;
  static inline bool Level_IsValid(int value) {
    return Response_LogEvent_Level_IsValid(value);
  }
  static const Level Level_MIN =
    Response_LogEvent_Level_Level_MIN;
  static const Level Level_MAX =
    Response_LogEvent_Level_Level_MAX;
  static const int Level_ARRAYSIZE =
    Response_LogEvent_Level_Level_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Level_descriptor() {
    return Response_LogEvent_Level_descriptor();
  }
  static inline const ::std::string& Level_Name(Level value) {
    return Response_LogEvent_Level_Name(value);
  }
  static inline bool Level_Parse(const ::std::string& name,
      Level* value) {
    return Response_LogEvent_Level_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .lms.Response.LogEvent.Level level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::lms::Response_LogEvent_Level level() const;
  inline void set_level(::lms::Response_LogEvent_Level value);

  // optional string tag = 2;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 2;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  inline void set_allocated_tag(::std::string* tag);

  // optional string text = 3;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 3;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional bool close_after = 4 [default = false];
  inline bool has_close_after() const;
  inline void clear_close_after();
  static const int kCloseAfterFieldNumber = 4;
  inline bool close_after() const;
  inline void set_close_after(bool value);

  // optional int64 timestamp = 5;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:lms.Response.LogEvent)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_close_after();
  inline void clear_has_close_after();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* tag_;
  int level_;
  bool close_after_;
  ::std::string* text_;
  ::google::protobuf::int64 timestamp_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_LogEvent* default_instance_;
};
// -------------------------------------------------------------------

class Response_ProfilingSummary_Trace : public ::google::protobuf::Message {
 public:
  Response_ProfilingSummary_Trace();
  virtual ~Response_ProfilingSummary_Trace();

  Response_ProfilingSummary_Trace(const Response_ProfilingSummary_Trace& from);

  inline Response_ProfilingSummary_Trace& operator=(const Response_ProfilingSummary_Trace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_ProfilingSummary_Trace& default_instance();

  void Swap(Response_ProfilingSummary_Trace* other);

  // implements Message ----------------------------------------------

  Response_ProfilingSummary_Trace* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_ProfilingSummary_Trace& from);
  void MergeFrom(const Response_ProfilingSummary_Trace& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 avg = 2;
  inline bool has_avg() const;
  inline void clear_avg();
  static const int kAvgFieldNumber = 2;
  inline ::google::protobuf::int32 avg() const;
  inline void set_avg(::google::protobuf::int32 value);

  // optional int32 std = 3;
  inline bool has_std() const;
  inline void clear_std();
  static const int kStdFieldNumber = 3;
  inline ::google::protobuf::int32 std() const;
  inline void set_std(::google::protobuf::int32 value);

  // optional int32 max = 4;
  inline bool has_max() const;
  inline void clear_max();
  static const int kMaxFieldNumber = 4;
  inline ::google::protobuf::int32 max() const;
  inline void set_max(::google::protobuf::int32 value);

  // optional int32 count = 5;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 5;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // optional int32 min = 6;
  inline bool has_min() const;
  inline void clear_min();
  static const int kMinFieldNumber = 6;
  inline ::google::protobuf::int32 min() const;
  inline void set_min(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:lms.Response.ProfilingSummary.Trace)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_avg();
  inline void clear_has_avg();
  inline void set_has_std();
  inline void clear_has_std();
  inline void set_has_max();
  inline void clear_has_max();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_min();
  inline void clear_has_min();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::int32 avg_;
  ::google::protobuf::int32 std_;
  ::google::protobuf::int32 max_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 min_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_ProfilingSummary_Trace* default_instance_;
};
// -------------------------------------------------------------------

class Response_ProfilingSummary : public ::google::protobuf::Message {
 public:
  Response_ProfilingSummary();
  virtual ~Response_ProfilingSummary();

  Response_ProfilingSummary(const Response_ProfilingSummary& from);

  inline Response_ProfilingSummary& operator=(const Response_ProfilingSummary& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_ProfilingSummary& default_instance();

  void Swap(Response_ProfilingSummary* other);

  // implements Message ----------------------------------------------

  Response_ProfilingSummary* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_ProfilingSummary& from);
  void MergeFrom(const Response_ProfilingSummary& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Response_ProfilingSummary_Trace Trace;

  // accessors -------------------------------------------------------

  // repeated .lms.Response.ProfilingSummary.Trace traces = 1;
  inline int traces_size() const;
  inline void clear_traces();
  static const int kTracesFieldNumber = 1;
  inline const ::lms::Response_ProfilingSummary_Trace& traces(int index) const;
  inline ::lms::Response_ProfilingSummary_Trace* mutable_traces(int index);
  inline ::lms::Response_ProfilingSummary_Trace* add_traces();
  inline const ::google::protobuf::RepeatedPtrField< ::lms::Response_ProfilingSummary_Trace >&
      traces() const;
  inline ::google::protobuf::RepeatedPtrField< ::lms::Response_ProfilingSummary_Trace >*
      mutable_traces();

  // @@protoc_insertion_point(class_scope:lms.Response.ProfilingSummary)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::lms::Response_ProfilingSummary_Trace > traces_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response_ProfilingSummary* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  enum ContentCase {
    kInfo = 1,
    kClientList = 2,
    kProcessList = 3,
    kModuleList = 4,
    kLogEvent = 5,
    kProfilingSummary = 6,
    CONTENT_NOT_SET = 0,
  };

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Response_Info Info;
  typedef Response_ClientList ClientList;
  typedef Response_ProcessList ProcessList;
  typedef Response_ModuleListResponse ModuleListResponse;
  typedef Response_LogEvent LogEvent;
  typedef Response_ProfilingSummary ProfilingSummary;

  // accessors -------------------------------------------------------

  // optional .lms.Response.Info info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::lms::Response_Info& info() const;
  inline ::lms::Response_Info* mutable_info();
  inline ::lms::Response_Info* release_info();
  inline void set_allocated_info(::lms::Response_Info* info);

  // optional .lms.Response.ClientList client_list = 2;
  inline bool has_client_list() const;
  inline void clear_client_list();
  static const int kClientListFieldNumber = 2;
  inline const ::lms::Response_ClientList& client_list() const;
  inline ::lms::Response_ClientList* mutable_client_list();
  inline ::lms::Response_ClientList* release_client_list();
  inline void set_allocated_client_list(::lms::Response_ClientList* client_list);

  // optional .lms.Response.ProcessList process_list = 3;
  inline bool has_process_list() const;
  inline void clear_process_list();
  static const int kProcessListFieldNumber = 3;
  inline const ::lms::Response_ProcessList& process_list() const;
  inline ::lms::Response_ProcessList* mutable_process_list();
  inline ::lms::Response_ProcessList* release_process_list();
  inline void set_allocated_process_list(::lms::Response_ProcessList* process_list);

  // optional .lms.Response.ModuleListResponse module_list = 4;
  inline bool has_module_list() const;
  inline void clear_module_list();
  static const int kModuleListFieldNumber = 4;
  inline const ::lms::Response_ModuleListResponse& module_list() const;
  inline ::lms::Response_ModuleListResponse* mutable_module_list();
  inline ::lms::Response_ModuleListResponse* release_module_list();
  inline void set_allocated_module_list(::lms::Response_ModuleListResponse* module_list);

  // optional .lms.Response.LogEvent log_event = 5;
  inline bool has_log_event() const;
  inline void clear_log_event();
  static const int kLogEventFieldNumber = 5;
  inline const ::lms::Response_LogEvent& log_event() const;
  inline ::lms::Response_LogEvent* mutable_log_event();
  inline ::lms::Response_LogEvent* release_log_event();
  inline void set_allocated_log_event(::lms::Response_LogEvent* log_event);

  // optional .lms.Response.ProfilingSummary profiling_summary = 6;
  inline bool has_profiling_summary() const;
  inline void clear_profiling_summary();
  static const int kProfilingSummaryFieldNumber = 6;
  inline const ::lms::Response_ProfilingSummary& profiling_summary() const;
  inline ::lms::Response_ProfilingSummary* mutable_profiling_summary();
  inline ::lms::Response_ProfilingSummary* release_profiling_summary();
  inline void set_allocated_profiling_summary(::lms::Response_ProfilingSummary* profiling_summary);

  inline ContentCase content_case() const;
  // @@protoc_insertion_point(class_scope:lms.Response)
 private:
  inline void set_has_info();
  inline void set_has_client_list();
  inline void set_has_process_list();
  inline void set_has_module_list();
  inline void set_has_log_event();
  inline void set_has_profiling_summary();

  inline bool has_content();
  void clear_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union ContentUnion {
    ::lms::Response_Info* info_;
    ::lms::Response_ClientList* client_list_;
    ::lms::Response_ProcessList* process_list_;
    ::lms::Response_ModuleListResponse* module_list_;
    ::lms::Response_LogEvent* log_event_;
    ::lms::Response_ProfilingSummary* profiling_summary_;
  } content_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// ===================================================================


// ===================================================================

// Request_Info

// -------------------------------------------------------------------

// Request_Shutdown

// -------------------------------------------------------------------

// Request_ListClients

// -------------------------------------------------------------------

// Request_Run

// optional string config_file = 1;
inline bool Request_Run::has_config_file() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_Run::set_has_config_file() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_Run::clear_has_config_file() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_Run::clear_config_file() {
  if (config_file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_->clear();
  }
  clear_has_config_file();
}
inline const ::std::string& Request_Run::config_file() const {
  // @@protoc_insertion_point(field_get:lms.Request.Run.config_file)
  return *config_file_;
}
inline void Request_Run::set_config_file(const ::std::string& value) {
  set_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_ = new ::std::string;
  }
  config_file_->assign(value);
  // @@protoc_insertion_point(field_set:lms.Request.Run.config_file)
}
inline void Request_Run::set_config_file(const char* value) {
  set_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_ = new ::std::string;
  }
  config_file_->assign(value);
  // @@protoc_insertion_point(field_set_char:lms.Request.Run.config_file)
}
inline void Request_Run::set_config_file(const char* value, size_t size) {
  set_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_ = new ::std::string;
  }
  config_file_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:lms.Request.Run.config_file)
}
inline ::std::string* Request_Run::mutable_config_file() {
  set_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:lms.Request.Run.config_file)
  return config_file_;
}
inline ::std::string* Request_Run::release_config_file() {
  clear_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = config_file_;
    config_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Request_Run::set_allocated_config_file(::std::string* config_file) {
  if (config_file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete config_file_;
  }
  if (config_file) {
    set_has_config_file();
    config_file_ = config_file;
  } else {
    clear_has_config_file();
    config_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:lms.Request.Run.config_file)
}

// repeated string include_paths = 2;
inline int Request_Run::include_paths_size() const {
  return include_paths_.size();
}
inline void Request_Run::clear_include_paths() {
  include_paths_.Clear();
}
inline const ::std::string& Request_Run::include_paths(int index) const {
  // @@protoc_insertion_point(field_get:lms.Request.Run.include_paths)
  return include_paths_.Get(index);
}
inline ::std::string* Request_Run::mutable_include_paths(int index) {
  // @@protoc_insertion_point(field_mutable:lms.Request.Run.include_paths)
  return include_paths_.Mutable(index);
}
inline void Request_Run::set_include_paths(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:lms.Request.Run.include_paths)
  include_paths_.Mutable(index)->assign(value);
}
inline void Request_Run::set_include_paths(int index, const char* value) {
  include_paths_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:lms.Request.Run.include_paths)
}
inline void Request_Run::set_include_paths(int index, const char* value, size_t size) {
  include_paths_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:lms.Request.Run.include_paths)
}
inline ::std::string* Request_Run::add_include_paths() {
  return include_paths_.Add();
}
inline void Request_Run::add_include_paths(const ::std::string& value) {
  include_paths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:lms.Request.Run.include_paths)
}
inline void Request_Run::add_include_paths(const char* value) {
  include_paths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:lms.Request.Run.include_paths)
}
inline void Request_Run::add_include_paths(const char* value, size_t size) {
  include_paths_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:lms.Request.Run.include_paths)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Request_Run::include_paths() const {
  // @@protoc_insertion_point(field_list:lms.Request.Run.include_paths)
  return include_paths_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Request_Run::mutable_include_paths() {
  // @@protoc_insertion_point(field_mutable_list:lms.Request.Run.include_paths)
  return &include_paths_;
}

// repeated string flags = 3;
inline int Request_Run::flags_size() const {
  return flags_.size();
}
inline void Request_Run::clear_flags() {
  flags_.Clear();
}
inline const ::std::string& Request_Run::flags(int index) const {
  // @@protoc_insertion_point(field_get:lms.Request.Run.flags)
  return flags_.Get(index);
}
inline ::std::string* Request_Run::mutable_flags(int index) {
  // @@protoc_insertion_point(field_mutable:lms.Request.Run.flags)
  return flags_.Mutable(index);
}
inline void Request_Run::set_flags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:lms.Request.Run.flags)
  flags_.Mutable(index)->assign(value);
}
inline void Request_Run::set_flags(int index, const char* value) {
  flags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:lms.Request.Run.flags)
}
inline void Request_Run::set_flags(int index, const char* value, size_t size) {
  flags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:lms.Request.Run.flags)
}
inline ::std::string* Request_Run::add_flags() {
  return flags_.Add();
}
inline void Request_Run::add_flags(const ::std::string& value) {
  flags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:lms.Request.Run.flags)
}
inline void Request_Run::add_flags(const char* value) {
  flags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:lms.Request.Run.flags)
}
inline void Request_Run::add_flags(const char* value, size_t size) {
  flags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:lms.Request.Run.flags)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Request_Run::flags() const {
  // @@protoc_insertion_point(field_list:lms.Request.Run.flags)
  return flags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Request_Run::mutable_flags() {
  // @@protoc_insertion_point(field_mutable_list:lms.Request.Run.flags)
  return &flags_;
}

// optional bool debug = 4;
inline bool Request_Run::has_debug() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request_Run::set_has_debug() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request_Run::clear_has_debug() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request_Run::clear_debug() {
  debug_ = false;
  clear_has_debug();
}
inline bool Request_Run::debug() const {
  // @@protoc_insertion_point(field_get:lms.Request.Run.debug)
  return debug_;
}
inline void Request_Run::set_debug(bool value) {
  set_has_debug();
  debug_ = value;
  // @@protoc_insertion_point(field_set:lms.Request.Run.debug)
}

// optional bool detached = 5 [default = false];
inline bool Request_Run::has_detached() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request_Run::set_has_detached() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request_Run::clear_has_detached() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request_Run::clear_detached() {
  detached_ = false;
  clear_has_detached();
}
inline bool Request_Run::detached() const {
  // @@protoc_insertion_point(field_get:lms.Request.Run.detached)
  return detached_;
}
inline void Request_Run::set_detached(bool value) {
  set_has_detached();
  detached_ = value;
  // @@protoc_insertion_point(field_set:lms.Request.Run.detached)
}

// optional bool shutdown_runtime_on_detach = 6 [default = false];
inline bool Request_Run::has_shutdown_runtime_on_detach() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Request_Run::set_has_shutdown_runtime_on_detach() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Request_Run::clear_has_shutdown_runtime_on_detach() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Request_Run::clear_shutdown_runtime_on_detach() {
  shutdown_runtime_on_detach_ = false;
  clear_has_shutdown_runtime_on_detach();
}
inline bool Request_Run::shutdown_runtime_on_detach() const {
  // @@protoc_insertion_point(field_get:lms.Request.Run.shutdown_runtime_on_detach)
  return shutdown_runtime_on_detach_;
}
inline void Request_Run::set_shutdown_runtime_on_detach(bool value) {
  set_has_shutdown_runtime_on_detach();
  shutdown_runtime_on_detach_ = value;
  // @@protoc_insertion_point(field_set:lms.Request.Run.shutdown_runtime_on_detach)
}

// -------------------------------------------------------------------

// Request_ListProcesses

// -------------------------------------------------------------------

// Request_Attach

// optional string id = 1;
inline bool Request_Attach::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_Attach::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_Attach::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_Attach::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Request_Attach::id() const {
  // @@protoc_insertion_point(field_get:lms.Request.Attach.id)
  return *id_;
}
inline void Request_Attach::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:lms.Request.Attach.id)
}
inline void Request_Attach::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:lms.Request.Attach.id)
}
inline void Request_Attach::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:lms.Request.Attach.id)
}
inline ::std::string* Request_Attach::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:lms.Request.Attach.id)
  return id_;
}
inline ::std::string* Request_Attach::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Request_Attach::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:lms.Request.Attach.id)
}

// -------------------------------------------------------------------

// Request_Stop

// optional string id = 1;
inline bool Request_Stop::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_Stop::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_Stop::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_Stop::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Request_Stop::id() const {
  // @@protoc_insertion_point(field_get:lms.Request.Stop.id)
  return *id_;
}
inline void Request_Stop::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:lms.Request.Stop.id)
}
inline void Request_Stop::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:lms.Request.Stop.id)
}
inline void Request_Stop::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:lms.Request.Stop.id)
}
inline ::std::string* Request_Stop::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:lms.Request.Stop.id)
  return id_;
}
inline ::std::string* Request_Stop::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Request_Stop::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:lms.Request.Stop.id)
}

// optional bool kill = 2;
inline bool Request_Stop::has_kill() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_Stop::set_has_kill() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_Stop::clear_has_kill() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_Stop::clear_kill() {
  kill_ = false;
  clear_has_kill();
}
inline bool Request_Stop::kill() const {
  // @@protoc_insertion_point(field_get:lms.Request.Stop.kill)
  return kill_;
}
inline void Request_Stop::set_kill(bool value) {
  set_has_kill();
  kill_ = value;
  // @@protoc_insertion_point(field_set:lms.Request.Stop.kill)
}

// -------------------------------------------------------------------

// Request_ModuleList

// -------------------------------------------------------------------

// Request_Profiling

// optional string id = 1;
inline bool Request_Profiling::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_Profiling::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_Profiling::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_Profiling::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Request_Profiling::id() const {
  // @@protoc_insertion_point(field_get:lms.Request.Profiling.id)
  return *id_;
}
inline void Request_Profiling::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:lms.Request.Profiling.id)
}
inline void Request_Profiling::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:lms.Request.Profiling.id)
}
inline void Request_Profiling::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:lms.Request.Profiling.id)
}
inline ::std::string* Request_Profiling::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:lms.Request.Profiling.id)
  return id_;
}
inline ::std::string* Request_Profiling::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Request_Profiling::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:lms.Request.Profiling.id)
}

// -------------------------------------------------------------------

// Request

// optional .lms.Request.Info info = 1;
inline bool Request::has_info() const {
  return content_case() == kInfo;
}
inline void Request::set_has_info() {
  _oneof_case_[0] = kInfo;
}
inline void Request::clear_info() {
  if (has_info()) {
    delete content_.info_;
    clear_has_content();
  }
}
inline const ::lms::Request_Info& Request::info() const {
  return has_info() ? *content_.info_
                      : ::lms::Request_Info::default_instance();
}
inline ::lms::Request_Info* Request::mutable_info() {
  if (!has_info()) {
    clear_content();
    set_has_info();
    content_.info_ = new ::lms::Request_Info;
  }
  return content_.info_;
}
inline ::lms::Request_Info* Request::release_info() {
  if (has_info()) {
    clear_has_content();
    ::lms::Request_Info* temp = content_.info_;
    content_.info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_info(::lms::Request_Info* info) {
  clear_content();
  if (info) {
    set_has_info();
    content_.info_ = info;
  }
}

// optional .lms.Request.Shutdown shutdown = 2;
inline bool Request::has_shutdown() const {
  return content_case() == kShutdown;
}
inline void Request::set_has_shutdown() {
  _oneof_case_[0] = kShutdown;
}
inline void Request::clear_shutdown() {
  if (has_shutdown()) {
    delete content_.shutdown_;
    clear_has_content();
  }
}
inline const ::lms::Request_Shutdown& Request::shutdown() const {
  return has_shutdown() ? *content_.shutdown_
                      : ::lms::Request_Shutdown::default_instance();
}
inline ::lms::Request_Shutdown* Request::mutable_shutdown() {
  if (!has_shutdown()) {
    clear_content();
    set_has_shutdown();
    content_.shutdown_ = new ::lms::Request_Shutdown;
  }
  return content_.shutdown_;
}
inline ::lms::Request_Shutdown* Request::release_shutdown() {
  if (has_shutdown()) {
    clear_has_content();
    ::lms::Request_Shutdown* temp = content_.shutdown_;
    content_.shutdown_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_shutdown(::lms::Request_Shutdown* shutdown) {
  clear_content();
  if (shutdown) {
    set_has_shutdown();
    content_.shutdown_ = shutdown;
  }
}

// optional .lms.Request.ListClients list_clients = 3;
inline bool Request::has_list_clients() const {
  return content_case() == kListClients;
}
inline void Request::set_has_list_clients() {
  _oneof_case_[0] = kListClients;
}
inline void Request::clear_list_clients() {
  if (has_list_clients()) {
    delete content_.list_clients_;
    clear_has_content();
  }
}
inline const ::lms::Request_ListClients& Request::list_clients() const {
  return has_list_clients() ? *content_.list_clients_
                      : ::lms::Request_ListClients::default_instance();
}
inline ::lms::Request_ListClients* Request::mutable_list_clients() {
  if (!has_list_clients()) {
    clear_content();
    set_has_list_clients();
    content_.list_clients_ = new ::lms::Request_ListClients;
  }
  return content_.list_clients_;
}
inline ::lms::Request_ListClients* Request::release_list_clients() {
  if (has_list_clients()) {
    clear_has_content();
    ::lms::Request_ListClients* temp = content_.list_clients_;
    content_.list_clients_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_list_clients(::lms::Request_ListClients* list_clients) {
  clear_content();
  if (list_clients) {
    set_has_list_clients();
    content_.list_clients_ = list_clients;
  }
}

// optional .lms.Request.Run run = 4;
inline bool Request::has_run() const {
  return content_case() == kRun;
}
inline void Request::set_has_run() {
  _oneof_case_[0] = kRun;
}
inline void Request::clear_run() {
  if (has_run()) {
    delete content_.run_;
    clear_has_content();
  }
}
inline const ::lms::Request_Run& Request::run() const {
  return has_run() ? *content_.run_
                      : ::lms::Request_Run::default_instance();
}
inline ::lms::Request_Run* Request::mutable_run() {
  if (!has_run()) {
    clear_content();
    set_has_run();
    content_.run_ = new ::lms::Request_Run;
  }
  return content_.run_;
}
inline ::lms::Request_Run* Request::release_run() {
  if (has_run()) {
    clear_has_content();
    ::lms::Request_Run* temp = content_.run_;
    content_.run_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_run(::lms::Request_Run* run) {
  clear_content();
  if (run) {
    set_has_run();
    content_.run_ = run;
  }
}

// optional .lms.Request.ListProcesses list_processes = 5;
inline bool Request::has_list_processes() const {
  return content_case() == kListProcesses;
}
inline void Request::set_has_list_processes() {
  _oneof_case_[0] = kListProcesses;
}
inline void Request::clear_list_processes() {
  if (has_list_processes()) {
    delete content_.list_processes_;
    clear_has_content();
  }
}
inline const ::lms::Request_ListProcesses& Request::list_processes() const {
  return has_list_processes() ? *content_.list_processes_
                      : ::lms::Request_ListProcesses::default_instance();
}
inline ::lms::Request_ListProcesses* Request::mutable_list_processes() {
  if (!has_list_processes()) {
    clear_content();
    set_has_list_processes();
    content_.list_processes_ = new ::lms::Request_ListProcesses;
  }
  return content_.list_processes_;
}
inline ::lms::Request_ListProcesses* Request::release_list_processes() {
  if (has_list_processes()) {
    clear_has_content();
    ::lms::Request_ListProcesses* temp = content_.list_processes_;
    content_.list_processes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_list_processes(::lms::Request_ListProcesses* list_processes) {
  clear_content();
  if (list_processes) {
    set_has_list_processes();
    content_.list_processes_ = list_processes;
  }
}

// optional .lms.Request.Attach attach = 6;
inline bool Request::has_attach() const {
  return content_case() == kAttach;
}
inline void Request::set_has_attach() {
  _oneof_case_[0] = kAttach;
}
inline void Request::clear_attach() {
  if (has_attach()) {
    delete content_.attach_;
    clear_has_content();
  }
}
inline const ::lms::Request_Attach& Request::attach() const {
  return has_attach() ? *content_.attach_
                      : ::lms::Request_Attach::default_instance();
}
inline ::lms::Request_Attach* Request::mutable_attach() {
  if (!has_attach()) {
    clear_content();
    set_has_attach();
    content_.attach_ = new ::lms::Request_Attach;
  }
  return content_.attach_;
}
inline ::lms::Request_Attach* Request::release_attach() {
  if (has_attach()) {
    clear_has_content();
    ::lms::Request_Attach* temp = content_.attach_;
    content_.attach_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_attach(::lms::Request_Attach* attach) {
  clear_content();
  if (attach) {
    set_has_attach();
    content_.attach_ = attach;
  }
}

// optional .lms.Request.Stop stop = 7;
inline bool Request::has_stop() const {
  return content_case() == kStop;
}
inline void Request::set_has_stop() {
  _oneof_case_[0] = kStop;
}
inline void Request::clear_stop() {
  if (has_stop()) {
    delete content_.stop_;
    clear_has_content();
  }
}
inline const ::lms::Request_Stop& Request::stop() const {
  return has_stop() ? *content_.stop_
                      : ::lms::Request_Stop::default_instance();
}
inline ::lms::Request_Stop* Request::mutable_stop() {
  if (!has_stop()) {
    clear_content();
    set_has_stop();
    content_.stop_ = new ::lms::Request_Stop;
  }
  return content_.stop_;
}
inline ::lms::Request_Stop* Request::release_stop() {
  if (has_stop()) {
    clear_has_content();
    ::lms::Request_Stop* temp = content_.stop_;
    content_.stop_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_stop(::lms::Request_Stop* stop) {
  clear_content();
  if (stop) {
    set_has_stop();
    content_.stop_ = stop;
  }
}

// optional .lms.Request.ModuleList module_list = 8;
inline bool Request::has_module_list() const {
  return content_case() == kModuleList;
}
inline void Request::set_has_module_list() {
  _oneof_case_[0] = kModuleList;
}
inline void Request::clear_module_list() {
  if (has_module_list()) {
    delete content_.module_list_;
    clear_has_content();
  }
}
inline const ::lms::Request_ModuleList& Request::module_list() const {
  return has_module_list() ? *content_.module_list_
                      : ::lms::Request_ModuleList::default_instance();
}
inline ::lms::Request_ModuleList* Request::mutable_module_list() {
  if (!has_module_list()) {
    clear_content();
    set_has_module_list();
    content_.module_list_ = new ::lms::Request_ModuleList;
  }
  return content_.module_list_;
}
inline ::lms::Request_ModuleList* Request::release_module_list() {
  if (has_module_list()) {
    clear_has_content();
    ::lms::Request_ModuleList* temp = content_.module_list_;
    content_.module_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_module_list(::lms::Request_ModuleList* module_list) {
  clear_content();
  if (module_list) {
    set_has_module_list();
    content_.module_list_ = module_list;
  }
}

// optional .lms.Request.Profiling profiling = 9;
inline bool Request::has_profiling() const {
  return content_case() == kProfiling;
}
inline void Request::set_has_profiling() {
  _oneof_case_[0] = kProfiling;
}
inline void Request::clear_profiling() {
  if (has_profiling()) {
    delete content_.profiling_;
    clear_has_content();
  }
}
inline const ::lms::Request_Profiling& Request::profiling() const {
  return has_profiling() ? *content_.profiling_
                      : ::lms::Request_Profiling::default_instance();
}
inline ::lms::Request_Profiling* Request::mutable_profiling() {
  if (!has_profiling()) {
    clear_content();
    set_has_profiling();
    content_.profiling_ = new ::lms::Request_Profiling;
  }
  return content_.profiling_;
}
inline ::lms::Request_Profiling* Request::release_profiling() {
  if (has_profiling()) {
    clear_has_content();
    ::lms::Request_Profiling* temp = content_.profiling_;
    content_.profiling_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_profiling(::lms::Request_Profiling* profiling) {
  clear_content();
  if (profiling) {
    set_has_profiling();
    content_.profiling_ = profiling;
  }
}

inline bool Request::has_content() {
  return content_case() != CONTENT_NOT_SET;
}
inline void Request::clear_has_content() {
  _oneof_case_[0] = CONTENT_NOT_SET;
}
inline Request::ContentCase Request::content_case() const {
  return Request::ContentCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Response_Info

// optional int32 version = 1;
inline bool Response_Info::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_Info::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_Info::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_Info::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 Response_Info::version() const {
  // @@protoc_insertion_point(field_get:lms.Response.Info.version)
  return version_;
}
inline void Response_Info::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:lms.Response.Info.version)
}

// optional int32 pid = 2;
inline bool Response_Info::has_pid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_Info::set_has_pid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_Info::clear_has_pid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_Info::clear_pid() {
  pid_ = 0;
  clear_has_pid();
}
inline ::google::protobuf::int32 Response_Info::pid() const {
  // @@protoc_insertion_point(field_get:lms.Response.Info.pid)
  return pid_;
}
inline void Response_Info::set_pid(::google::protobuf::int32 value) {
  set_has_pid();
  pid_ = value;
  // @@protoc_insertion_point(field_set:lms.Response.Info.pid)
}

// -------------------------------------------------------------------

// Response_ClientList_Client

// optional int32 fd = 1;
inline bool Response_ClientList_Client::has_fd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_ClientList_Client::set_has_fd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_ClientList_Client::clear_has_fd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_ClientList_Client::clear_fd() {
  fd_ = 0;
  clear_has_fd();
}
inline ::google::protobuf::int32 Response_ClientList_Client::fd() const {
  // @@protoc_insertion_point(field_get:lms.Response.ClientList.Client.fd)
  return fd_;
}
inline void Response_ClientList_Client::set_fd(::google::protobuf::int32 value) {
  set_has_fd();
  fd_ = value;
  // @@protoc_insertion_point(field_set:lms.Response.ClientList.Client.fd)
}

// optional string peer = 2;
inline bool Response_ClientList_Client::has_peer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_ClientList_Client::set_has_peer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_ClientList_Client::clear_has_peer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_ClientList_Client::clear_peer() {
  if (peer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    peer_->clear();
  }
  clear_has_peer();
}
inline const ::std::string& Response_ClientList_Client::peer() const {
  // @@protoc_insertion_point(field_get:lms.Response.ClientList.Client.peer)
  return *peer_;
}
inline void Response_ClientList_Client::set_peer(const ::std::string& value) {
  set_has_peer();
  if (peer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    peer_ = new ::std::string;
  }
  peer_->assign(value);
  // @@protoc_insertion_point(field_set:lms.Response.ClientList.Client.peer)
}
inline void Response_ClientList_Client::set_peer(const char* value) {
  set_has_peer();
  if (peer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    peer_ = new ::std::string;
  }
  peer_->assign(value);
  // @@protoc_insertion_point(field_set_char:lms.Response.ClientList.Client.peer)
}
inline void Response_ClientList_Client::set_peer(const char* value, size_t size) {
  set_has_peer();
  if (peer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    peer_ = new ::std::string;
  }
  peer_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:lms.Response.ClientList.Client.peer)
}
inline ::std::string* Response_ClientList_Client::mutable_peer() {
  set_has_peer();
  if (peer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    peer_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:lms.Response.ClientList.Client.peer)
  return peer_;
}
inline ::std::string* Response_ClientList_Client::release_peer() {
  clear_has_peer();
  if (peer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = peer_;
    peer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Response_ClientList_Client::set_allocated_peer(::std::string* peer) {
  if (peer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete peer_;
  }
  if (peer) {
    set_has_peer();
    peer_ = peer;
  } else {
    clear_has_peer();
    peer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:lms.Response.ClientList.Client.peer)
}

// -------------------------------------------------------------------

// Response_ClientList

// repeated .lms.Response.ClientList.Client clients = 1;
inline int Response_ClientList::clients_size() const {
  return clients_.size();
}
inline void Response_ClientList::clear_clients() {
  clients_.Clear();
}
inline const ::lms::Response_ClientList_Client& Response_ClientList::clients(int index) const {
  // @@protoc_insertion_point(field_get:lms.Response.ClientList.clients)
  return clients_.Get(index);
}
inline ::lms::Response_ClientList_Client* Response_ClientList::mutable_clients(int index) {
  // @@protoc_insertion_point(field_mutable:lms.Response.ClientList.clients)
  return clients_.Mutable(index);
}
inline ::lms::Response_ClientList_Client* Response_ClientList::add_clients() {
  // @@protoc_insertion_point(field_add:lms.Response.ClientList.clients)
  return clients_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lms::Response_ClientList_Client >&
Response_ClientList::clients() const {
  // @@protoc_insertion_point(field_list:lms.Response.ClientList.clients)
  return clients_;
}
inline ::google::protobuf::RepeatedPtrField< ::lms::Response_ClientList_Client >*
Response_ClientList::mutable_clients() {
  // @@protoc_insertion_point(field_mutable_list:lms.Response.ClientList.clients)
  return &clients_;
}

// -------------------------------------------------------------------

// Response_ProcessList_Process

// optional int32 pid = 1;
inline bool Response_ProcessList_Process::has_pid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_ProcessList_Process::set_has_pid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_ProcessList_Process::clear_has_pid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_ProcessList_Process::clear_pid() {
  pid_ = 0;
  clear_has_pid();
}
inline ::google::protobuf::int32 Response_ProcessList_Process::pid() const {
  // @@protoc_insertion_point(field_get:lms.Response.ProcessList.Process.pid)
  return pid_;
}
inline void Response_ProcessList_Process::set_pid(::google::protobuf::int32 value) {
  set_has_pid();
  pid_ = value;
  // @@protoc_insertion_point(field_set:lms.Response.ProcessList.Process.pid)
}

// optional string config_file = 2;
inline bool Response_ProcessList_Process::has_config_file() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_ProcessList_Process::set_has_config_file() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_ProcessList_Process::clear_has_config_file() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_ProcessList_Process::clear_config_file() {
  if (config_file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_->clear();
  }
  clear_has_config_file();
}
inline const ::std::string& Response_ProcessList_Process::config_file() const {
  // @@protoc_insertion_point(field_get:lms.Response.ProcessList.Process.config_file)
  return *config_file_;
}
inline void Response_ProcessList_Process::set_config_file(const ::std::string& value) {
  set_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_ = new ::std::string;
  }
  config_file_->assign(value);
  // @@protoc_insertion_point(field_set:lms.Response.ProcessList.Process.config_file)
}
inline void Response_ProcessList_Process::set_config_file(const char* value) {
  set_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_ = new ::std::string;
  }
  config_file_->assign(value);
  // @@protoc_insertion_point(field_set_char:lms.Response.ProcessList.Process.config_file)
}
inline void Response_ProcessList_Process::set_config_file(const char* value, size_t size) {
  set_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_ = new ::std::string;
  }
  config_file_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:lms.Response.ProcessList.Process.config_file)
}
inline ::std::string* Response_ProcessList_Process::mutable_config_file() {
  set_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:lms.Response.ProcessList.Process.config_file)
  return config_file_;
}
inline ::std::string* Response_ProcessList_Process::release_config_file() {
  clear_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = config_file_;
    config_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Response_ProcessList_Process::set_allocated_config_file(::std::string* config_file) {
  if (config_file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete config_file_;
  }
  if (config_file) {
    set_has_config_file();
    config_file_ = config_file;
  } else {
    clear_has_config_file();
    config_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:lms.Response.ProcessList.Process.config_file)
}

// -------------------------------------------------------------------

// Response_ProcessList

// repeated .lms.Response.ProcessList.Process processes = 1;
inline int Response_ProcessList::processes_size() const {
  return processes_.size();
}
inline void Response_ProcessList::clear_processes() {
  processes_.Clear();
}
inline const ::lms::Response_ProcessList_Process& Response_ProcessList::processes(int index) const {
  // @@protoc_insertion_point(field_get:lms.Response.ProcessList.processes)
  return processes_.Get(index);
}
inline ::lms::Response_ProcessList_Process* Response_ProcessList::mutable_processes(int index) {
  // @@protoc_insertion_point(field_mutable:lms.Response.ProcessList.processes)
  return processes_.Mutable(index);
}
inline ::lms::Response_ProcessList_Process* Response_ProcessList::add_processes() {
  // @@protoc_insertion_point(field_add:lms.Response.ProcessList.processes)
  return processes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lms::Response_ProcessList_Process >&
Response_ProcessList::processes() const {
  // @@protoc_insertion_point(field_list:lms.Response.ProcessList.processes)
  return processes_;
}
inline ::google::protobuf::RepeatedPtrField< ::lms::Response_ProcessList_Process >*
Response_ProcessList::mutable_processes() {
  // @@protoc_insertion_point(field_mutable_list:lms.Response.ProcessList.processes)
  return &processes_;
}

// -------------------------------------------------------------------

// Response_ModuleListResponse_Access

// optional string module = 1;
inline bool Response_ModuleListResponse_Access::has_module() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_ModuleListResponse_Access::set_has_module() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_ModuleListResponse_Access::clear_has_module() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_ModuleListResponse_Access::clear_module() {
  if (module_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    module_->clear();
  }
  clear_has_module();
}
inline const ::std::string& Response_ModuleListResponse_Access::module() const {
  // @@protoc_insertion_point(field_get:lms.Response.ModuleListResponse.Access.module)
  return *module_;
}
inline void Response_ModuleListResponse_Access::set_module(const ::std::string& value) {
  set_has_module();
  if (module_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    module_ = new ::std::string;
  }
  module_->assign(value);
  // @@protoc_insertion_point(field_set:lms.Response.ModuleListResponse.Access.module)
}
inline void Response_ModuleListResponse_Access::set_module(const char* value) {
  set_has_module();
  if (module_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    module_ = new ::std::string;
  }
  module_->assign(value);
  // @@protoc_insertion_point(field_set_char:lms.Response.ModuleListResponse.Access.module)
}
inline void Response_ModuleListResponse_Access::set_module(const char* value, size_t size) {
  set_has_module();
  if (module_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    module_ = new ::std::string;
  }
  module_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:lms.Response.ModuleListResponse.Access.module)
}
inline ::std::string* Response_ModuleListResponse_Access::mutable_module() {
  set_has_module();
  if (module_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    module_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:lms.Response.ModuleListResponse.Access.module)
  return module_;
}
inline ::std::string* Response_ModuleListResponse_Access::release_module() {
  clear_has_module();
  if (module_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = module_;
    module_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Response_ModuleListResponse_Access::set_allocated_module(::std::string* module) {
  if (module_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete module_;
  }
  if (module) {
    set_has_module();
    module_ = module;
  } else {
    clear_has_module();
    module_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:lms.Response.ModuleListResponse.Access.module)
}

// optional .lms.Response.ModuleListResponse.Permission permission = 2;
inline bool Response_ModuleListResponse_Access::has_permission() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_ModuleListResponse_Access::set_has_permission() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_ModuleListResponse_Access::clear_has_permission() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_ModuleListResponse_Access::clear_permission() {
  permission_ = 1;
  clear_has_permission();
}
inline ::lms::Response_ModuleListResponse_Permission Response_ModuleListResponse_Access::permission() const {
  // @@protoc_insertion_point(field_get:lms.Response.ModuleListResponse.Access.permission)
  return static_cast< ::lms::Response_ModuleListResponse_Permission >(permission_);
}
inline void Response_ModuleListResponse_Access::set_permission(::lms::Response_ModuleListResponse_Permission value) {
  assert(::lms::Response_ModuleListResponse_Permission_IsValid(value));
  set_has_permission();
  permission_ = value;
  // @@protoc_insertion_point(field_set:lms.Response.ModuleListResponse.Access.permission)
}

// optional int32 priority = 3;
inline bool Response_ModuleListResponse_Access::has_priority() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response_ModuleListResponse_Access::set_has_priority() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response_ModuleListResponse_Access::clear_has_priority() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response_ModuleListResponse_Access::clear_priority() {
  priority_ = 0;
  clear_has_priority();
}
inline ::google::protobuf::int32 Response_ModuleListResponse_Access::priority() const {
  // @@protoc_insertion_point(field_get:lms.Response.ModuleListResponse.Access.priority)
  return priority_;
}
inline void Response_ModuleListResponse_Access::set_priority(::google::protobuf::int32 value) {
  set_has_priority();
  priority_ = value;
  // @@protoc_insertion_point(field_set:lms.Response.ModuleListResponse.Access.priority)
}

// -------------------------------------------------------------------

// Response_ModuleListResponse_Channel

// optional string name = 1;
inline bool Response_ModuleListResponse_Channel::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_ModuleListResponse_Channel::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_ModuleListResponse_Channel::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_ModuleListResponse_Channel::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Response_ModuleListResponse_Channel::name() const {
  // @@protoc_insertion_point(field_get:lms.Response.ModuleListResponse.Channel.name)
  return *name_;
}
inline void Response_ModuleListResponse_Channel::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:lms.Response.ModuleListResponse.Channel.name)
}
inline void Response_ModuleListResponse_Channel::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:lms.Response.ModuleListResponse.Channel.name)
}
inline void Response_ModuleListResponse_Channel::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:lms.Response.ModuleListResponse.Channel.name)
}
inline ::std::string* Response_ModuleListResponse_Channel::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:lms.Response.ModuleListResponse.Channel.name)
  return name_;
}
inline ::std::string* Response_ModuleListResponse_Channel::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Response_ModuleListResponse_Channel::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:lms.Response.ModuleListResponse.Channel.name)
}

// repeated .lms.Response.ModuleListResponse.Access access_list = 2;
inline int Response_ModuleListResponse_Channel::access_list_size() const {
  return access_list_.size();
}
inline void Response_ModuleListResponse_Channel::clear_access_list() {
  access_list_.Clear();
}
inline const ::lms::Response_ModuleListResponse_Access& Response_ModuleListResponse_Channel::access_list(int index) const {
  // @@protoc_insertion_point(field_get:lms.Response.ModuleListResponse.Channel.access_list)
  return access_list_.Get(index);
}
inline ::lms::Response_ModuleListResponse_Access* Response_ModuleListResponse_Channel::mutable_access_list(int index) {
  // @@protoc_insertion_point(field_mutable:lms.Response.ModuleListResponse.Channel.access_list)
  return access_list_.Mutable(index);
}
inline ::lms::Response_ModuleListResponse_Access* Response_ModuleListResponse_Channel::add_access_list() {
  // @@protoc_insertion_point(field_add:lms.Response.ModuleListResponse.Channel.access_list)
  return access_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lms::Response_ModuleListResponse_Access >&
Response_ModuleListResponse_Channel::access_list() const {
  // @@protoc_insertion_point(field_list:lms.Response.ModuleListResponse.Channel.access_list)
  return access_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::lms::Response_ModuleListResponse_Access >*
Response_ModuleListResponse_Channel::mutable_access_list() {
  // @@protoc_insertion_point(field_mutable_list:lms.Response.ModuleListResponse.Channel.access_list)
  return &access_list_;
}

// -------------------------------------------------------------------

// Response_ModuleListResponse

// repeated .lms.Response.ModuleListResponse.Channel channels = 1;
inline int Response_ModuleListResponse::channels_size() const {
  return channels_.size();
}
inline void Response_ModuleListResponse::clear_channels() {
  channels_.Clear();
}
inline const ::lms::Response_ModuleListResponse_Channel& Response_ModuleListResponse::channels(int index) const {
  // @@protoc_insertion_point(field_get:lms.Response.ModuleListResponse.channels)
  return channels_.Get(index);
}
inline ::lms::Response_ModuleListResponse_Channel* Response_ModuleListResponse::mutable_channels(int index) {
  // @@protoc_insertion_point(field_mutable:lms.Response.ModuleListResponse.channels)
  return channels_.Mutable(index);
}
inline ::lms::Response_ModuleListResponse_Channel* Response_ModuleListResponse::add_channels() {
  // @@protoc_insertion_point(field_add:lms.Response.ModuleListResponse.channels)
  return channels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lms::Response_ModuleListResponse_Channel >&
Response_ModuleListResponse::channels() const {
  // @@protoc_insertion_point(field_list:lms.Response.ModuleListResponse.channels)
  return channels_;
}
inline ::google::protobuf::RepeatedPtrField< ::lms::Response_ModuleListResponse_Channel >*
Response_ModuleListResponse::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:lms.Response.ModuleListResponse.channels)
  return &channels_;
}

// -------------------------------------------------------------------

// Response_LogEvent

// optional .lms.Response.LogEvent.Level level = 1;
inline bool Response_LogEvent::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_LogEvent::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_LogEvent::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_LogEvent::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::lms::Response_LogEvent_Level Response_LogEvent::level() const {
  // @@protoc_insertion_point(field_get:lms.Response.LogEvent.level)
  return static_cast< ::lms::Response_LogEvent_Level >(level_);
}
inline void Response_LogEvent::set_level(::lms::Response_LogEvent_Level value) {
  assert(::lms::Response_LogEvent_Level_IsValid(value));
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:lms.Response.LogEvent.level)
}

// optional string tag = 2;
inline bool Response_LogEvent::has_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_LogEvent::set_has_tag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_LogEvent::clear_has_tag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_LogEvent::clear_tag() {
  if (tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& Response_LogEvent::tag() const {
  // @@protoc_insertion_point(field_get:lms.Response.LogEvent.tag)
  return *tag_;
}
inline void Response_LogEvent::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
  // @@protoc_insertion_point(field_set:lms.Response.LogEvent.tag)
}
inline void Response_LogEvent::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
  // @@protoc_insertion_point(field_set_char:lms.Response.LogEvent.tag)
}
inline void Response_LogEvent::set_tag(const char* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:lms.Response.LogEvent.tag)
}
inline ::std::string* Response_LogEvent::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:lms.Response.LogEvent.tag)
  return tag_;
}
inline ::std::string* Response_LogEvent::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Response_LogEvent::set_allocated_tag(::std::string* tag) {
  if (tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tag_;
  }
  if (tag) {
    set_has_tag();
    tag_ = tag;
  } else {
    clear_has_tag();
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:lms.Response.LogEvent.tag)
}

// optional string text = 3;
inline bool Response_LogEvent::has_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response_LogEvent::set_has_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response_LogEvent::clear_has_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response_LogEvent::clear_text() {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& Response_LogEvent::text() const {
  // @@protoc_insertion_point(field_get:lms.Response.LogEvent.text)
  return *text_;
}
inline void Response_LogEvent::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set:lms.Response.LogEvent.text)
}
inline void Response_LogEvent::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set_char:lms.Response.LogEvent.text)
}
inline void Response_LogEvent::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:lms.Response.LogEvent.text)
}
inline ::std::string* Response_LogEvent::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:lms.Response.LogEvent.text)
  return text_;
}
inline ::std::string* Response_LogEvent::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Response_LogEvent::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:lms.Response.LogEvent.text)
}

// optional bool close_after = 4 [default = false];
inline bool Response_LogEvent::has_close_after() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response_LogEvent::set_has_close_after() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response_LogEvent::clear_has_close_after() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response_LogEvent::clear_close_after() {
  close_after_ = false;
  clear_has_close_after();
}
inline bool Response_LogEvent::close_after() const {
  // @@protoc_insertion_point(field_get:lms.Response.LogEvent.close_after)
  return close_after_;
}
inline void Response_LogEvent::set_close_after(bool value) {
  set_has_close_after();
  close_after_ = value;
  // @@protoc_insertion_point(field_set:lms.Response.LogEvent.close_after)
}

// optional int64 timestamp = 5;
inline bool Response_LogEvent::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Response_LogEvent::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Response_LogEvent::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Response_LogEvent::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 Response_LogEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:lms.Response.LogEvent.timestamp)
  return timestamp_;
}
inline void Response_LogEvent::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:lms.Response.LogEvent.timestamp)
}

// -------------------------------------------------------------------

// Response_ProfilingSummary_Trace

// optional string name = 1;
inline bool Response_ProfilingSummary_Trace::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response_ProfilingSummary_Trace::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response_ProfilingSummary_Trace::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response_ProfilingSummary_Trace::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Response_ProfilingSummary_Trace::name() const {
  // @@protoc_insertion_point(field_get:lms.Response.ProfilingSummary.Trace.name)
  return *name_;
}
inline void Response_ProfilingSummary_Trace::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:lms.Response.ProfilingSummary.Trace.name)
}
inline void Response_ProfilingSummary_Trace::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:lms.Response.ProfilingSummary.Trace.name)
}
inline void Response_ProfilingSummary_Trace::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:lms.Response.ProfilingSummary.Trace.name)
}
inline ::std::string* Response_ProfilingSummary_Trace::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:lms.Response.ProfilingSummary.Trace.name)
  return name_;
}
inline ::std::string* Response_ProfilingSummary_Trace::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Response_ProfilingSummary_Trace::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:lms.Response.ProfilingSummary.Trace.name)
}

// optional int32 avg = 2;
inline bool Response_ProfilingSummary_Trace::has_avg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response_ProfilingSummary_Trace::set_has_avg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response_ProfilingSummary_Trace::clear_has_avg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response_ProfilingSummary_Trace::clear_avg() {
  avg_ = 0;
  clear_has_avg();
}
inline ::google::protobuf::int32 Response_ProfilingSummary_Trace::avg() const {
  // @@protoc_insertion_point(field_get:lms.Response.ProfilingSummary.Trace.avg)
  return avg_;
}
inline void Response_ProfilingSummary_Trace::set_avg(::google::protobuf::int32 value) {
  set_has_avg();
  avg_ = value;
  // @@protoc_insertion_point(field_set:lms.Response.ProfilingSummary.Trace.avg)
}

// optional int32 std = 3;
inline bool Response_ProfilingSummary_Trace::has_std() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response_ProfilingSummary_Trace::set_has_std() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response_ProfilingSummary_Trace::clear_has_std() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response_ProfilingSummary_Trace::clear_std() {
  std_ = 0;
  clear_has_std();
}
inline ::google::protobuf::int32 Response_ProfilingSummary_Trace::std() const {
  // @@protoc_insertion_point(field_get:lms.Response.ProfilingSummary.Trace.std)
  return std_;
}
inline void Response_ProfilingSummary_Trace::set_std(::google::protobuf::int32 value) {
  set_has_std();
  std_ = value;
  // @@protoc_insertion_point(field_set:lms.Response.ProfilingSummary.Trace.std)
}

// optional int32 max = 4;
inline bool Response_ProfilingSummary_Trace::has_max() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response_ProfilingSummary_Trace::set_has_max() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response_ProfilingSummary_Trace::clear_has_max() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response_ProfilingSummary_Trace::clear_max() {
  max_ = 0;
  clear_has_max();
}
inline ::google::protobuf::int32 Response_ProfilingSummary_Trace::max() const {
  // @@protoc_insertion_point(field_get:lms.Response.ProfilingSummary.Trace.max)
  return max_;
}
inline void Response_ProfilingSummary_Trace::set_max(::google::protobuf::int32 value) {
  set_has_max();
  max_ = value;
  // @@protoc_insertion_point(field_set:lms.Response.ProfilingSummary.Trace.max)
}

// optional int32 count = 5;
inline bool Response_ProfilingSummary_Trace::has_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Response_ProfilingSummary_Trace::set_has_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Response_ProfilingSummary_Trace::clear_has_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Response_ProfilingSummary_Trace::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 Response_ProfilingSummary_Trace::count() const {
  // @@protoc_insertion_point(field_get:lms.Response.ProfilingSummary.Trace.count)
  return count_;
}
inline void Response_ProfilingSummary_Trace::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:lms.Response.ProfilingSummary.Trace.count)
}

// optional int32 min = 6;
inline bool Response_ProfilingSummary_Trace::has_min() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Response_ProfilingSummary_Trace::set_has_min() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Response_ProfilingSummary_Trace::clear_has_min() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Response_ProfilingSummary_Trace::clear_min() {
  min_ = 0;
  clear_has_min();
}
inline ::google::protobuf::int32 Response_ProfilingSummary_Trace::min() const {
  // @@protoc_insertion_point(field_get:lms.Response.ProfilingSummary.Trace.min)
  return min_;
}
inline void Response_ProfilingSummary_Trace::set_min(::google::protobuf::int32 value) {
  set_has_min();
  min_ = value;
  // @@protoc_insertion_point(field_set:lms.Response.ProfilingSummary.Trace.min)
}

// -------------------------------------------------------------------

// Response_ProfilingSummary

// repeated .lms.Response.ProfilingSummary.Trace traces = 1;
inline int Response_ProfilingSummary::traces_size() const {
  return traces_.size();
}
inline void Response_ProfilingSummary::clear_traces() {
  traces_.Clear();
}
inline const ::lms::Response_ProfilingSummary_Trace& Response_ProfilingSummary::traces(int index) const {
  // @@protoc_insertion_point(field_get:lms.Response.ProfilingSummary.traces)
  return traces_.Get(index);
}
inline ::lms::Response_ProfilingSummary_Trace* Response_ProfilingSummary::mutable_traces(int index) {
  // @@protoc_insertion_point(field_mutable:lms.Response.ProfilingSummary.traces)
  return traces_.Mutable(index);
}
inline ::lms::Response_ProfilingSummary_Trace* Response_ProfilingSummary::add_traces() {
  // @@protoc_insertion_point(field_add:lms.Response.ProfilingSummary.traces)
  return traces_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lms::Response_ProfilingSummary_Trace >&
Response_ProfilingSummary::traces() const {
  // @@protoc_insertion_point(field_list:lms.Response.ProfilingSummary.traces)
  return traces_;
}
inline ::google::protobuf::RepeatedPtrField< ::lms::Response_ProfilingSummary_Trace >*
Response_ProfilingSummary::mutable_traces() {
  // @@protoc_insertion_point(field_mutable_list:lms.Response.ProfilingSummary.traces)
  return &traces_;
}

// -------------------------------------------------------------------

// Response

// optional .lms.Response.Info info = 1;
inline bool Response::has_info() const {
  return content_case() == kInfo;
}
inline void Response::set_has_info() {
  _oneof_case_[0] = kInfo;
}
inline void Response::clear_info() {
  if (has_info()) {
    delete content_.info_;
    clear_has_content();
  }
}
inline const ::lms::Response_Info& Response::info() const {
  return has_info() ? *content_.info_
                      : ::lms::Response_Info::default_instance();
}
inline ::lms::Response_Info* Response::mutable_info() {
  if (!has_info()) {
    clear_content();
    set_has_info();
    content_.info_ = new ::lms::Response_Info;
  }
  return content_.info_;
}
inline ::lms::Response_Info* Response::release_info() {
  if (has_info()) {
    clear_has_content();
    ::lms::Response_Info* temp = content_.info_;
    content_.info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_info(::lms::Response_Info* info) {
  clear_content();
  if (info) {
    set_has_info();
    content_.info_ = info;
  }
}

// optional .lms.Response.ClientList client_list = 2;
inline bool Response::has_client_list() const {
  return content_case() == kClientList;
}
inline void Response::set_has_client_list() {
  _oneof_case_[0] = kClientList;
}
inline void Response::clear_client_list() {
  if (has_client_list()) {
    delete content_.client_list_;
    clear_has_content();
  }
}
inline const ::lms::Response_ClientList& Response::client_list() const {
  return has_client_list() ? *content_.client_list_
                      : ::lms::Response_ClientList::default_instance();
}
inline ::lms::Response_ClientList* Response::mutable_client_list() {
  if (!has_client_list()) {
    clear_content();
    set_has_client_list();
    content_.client_list_ = new ::lms::Response_ClientList;
  }
  return content_.client_list_;
}
inline ::lms::Response_ClientList* Response::release_client_list() {
  if (has_client_list()) {
    clear_has_content();
    ::lms::Response_ClientList* temp = content_.client_list_;
    content_.client_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_client_list(::lms::Response_ClientList* client_list) {
  clear_content();
  if (client_list) {
    set_has_client_list();
    content_.client_list_ = client_list;
  }
}

// optional .lms.Response.ProcessList process_list = 3;
inline bool Response::has_process_list() const {
  return content_case() == kProcessList;
}
inline void Response::set_has_process_list() {
  _oneof_case_[0] = kProcessList;
}
inline void Response::clear_process_list() {
  if (has_process_list()) {
    delete content_.process_list_;
    clear_has_content();
  }
}
inline const ::lms::Response_ProcessList& Response::process_list() const {
  return has_process_list() ? *content_.process_list_
                      : ::lms::Response_ProcessList::default_instance();
}
inline ::lms::Response_ProcessList* Response::mutable_process_list() {
  if (!has_process_list()) {
    clear_content();
    set_has_process_list();
    content_.process_list_ = new ::lms::Response_ProcessList;
  }
  return content_.process_list_;
}
inline ::lms::Response_ProcessList* Response::release_process_list() {
  if (has_process_list()) {
    clear_has_content();
    ::lms::Response_ProcessList* temp = content_.process_list_;
    content_.process_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_process_list(::lms::Response_ProcessList* process_list) {
  clear_content();
  if (process_list) {
    set_has_process_list();
    content_.process_list_ = process_list;
  }
}

// optional .lms.Response.ModuleListResponse module_list = 4;
inline bool Response::has_module_list() const {
  return content_case() == kModuleList;
}
inline void Response::set_has_module_list() {
  _oneof_case_[0] = kModuleList;
}
inline void Response::clear_module_list() {
  if (has_module_list()) {
    delete content_.module_list_;
    clear_has_content();
  }
}
inline const ::lms::Response_ModuleListResponse& Response::module_list() const {
  return has_module_list() ? *content_.module_list_
                      : ::lms::Response_ModuleListResponse::default_instance();
}
inline ::lms::Response_ModuleListResponse* Response::mutable_module_list() {
  if (!has_module_list()) {
    clear_content();
    set_has_module_list();
    content_.module_list_ = new ::lms::Response_ModuleListResponse;
  }
  return content_.module_list_;
}
inline ::lms::Response_ModuleListResponse* Response::release_module_list() {
  if (has_module_list()) {
    clear_has_content();
    ::lms::Response_ModuleListResponse* temp = content_.module_list_;
    content_.module_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_module_list(::lms::Response_ModuleListResponse* module_list) {
  clear_content();
  if (module_list) {
    set_has_module_list();
    content_.module_list_ = module_list;
  }
}

// optional .lms.Response.LogEvent log_event = 5;
inline bool Response::has_log_event() const {
  return content_case() == kLogEvent;
}
inline void Response::set_has_log_event() {
  _oneof_case_[0] = kLogEvent;
}
inline void Response::clear_log_event() {
  if (has_log_event()) {
    delete content_.log_event_;
    clear_has_content();
  }
}
inline const ::lms::Response_LogEvent& Response::log_event() const {
  return has_log_event() ? *content_.log_event_
                      : ::lms::Response_LogEvent::default_instance();
}
inline ::lms::Response_LogEvent* Response::mutable_log_event() {
  if (!has_log_event()) {
    clear_content();
    set_has_log_event();
    content_.log_event_ = new ::lms::Response_LogEvent;
  }
  return content_.log_event_;
}
inline ::lms::Response_LogEvent* Response::release_log_event() {
  if (has_log_event()) {
    clear_has_content();
    ::lms::Response_LogEvent* temp = content_.log_event_;
    content_.log_event_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_log_event(::lms::Response_LogEvent* log_event) {
  clear_content();
  if (log_event) {
    set_has_log_event();
    content_.log_event_ = log_event;
  }
}

// optional .lms.Response.ProfilingSummary profiling_summary = 6;
inline bool Response::has_profiling_summary() const {
  return content_case() == kProfilingSummary;
}
inline void Response::set_has_profiling_summary() {
  _oneof_case_[0] = kProfilingSummary;
}
inline void Response::clear_profiling_summary() {
  if (has_profiling_summary()) {
    delete content_.profiling_summary_;
    clear_has_content();
  }
}
inline const ::lms::Response_ProfilingSummary& Response::profiling_summary() const {
  return has_profiling_summary() ? *content_.profiling_summary_
                      : ::lms::Response_ProfilingSummary::default_instance();
}
inline ::lms::Response_ProfilingSummary* Response::mutable_profiling_summary() {
  if (!has_profiling_summary()) {
    clear_content();
    set_has_profiling_summary();
    content_.profiling_summary_ = new ::lms::Response_ProfilingSummary;
  }
  return content_.profiling_summary_;
}
inline ::lms::Response_ProfilingSummary* Response::release_profiling_summary() {
  if (has_profiling_summary()) {
    clear_has_content();
    ::lms::Response_ProfilingSummary* temp = content_.profiling_summary_;
    content_.profiling_summary_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_profiling_summary(::lms::Response_ProfilingSummary* profiling_summary) {
  clear_content();
  if (profiling_summary) {
    set_has_profiling_summary();
    content_.profiling_summary_ = profiling_summary;
  }
}

inline bool Response::has_content() {
  return content_case() != CONTENT_NOT_SET;
}
inline void Response::clear_has_content() {
  _oneof_case_[0] = CONTENT_NOT_SET;
}
inline Response::ContentCase Response::content_case() const {
  return Response::ContentCase(_oneof_case_[0]);
}

// @@protoc_insertion_point(namespace_scope)

}  // namespace lms

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::lms::Response_ModuleListResponse_Permission> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lms::Response_ModuleListResponse_Permission>() {
  return ::lms::Response_ModuleListResponse_Permission_descriptor();
}
template <> struct is_proto_enum< ::lms::Response_LogEvent_Level> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lms::Response_LogEvent_Level>() {
  return ::lms::Response_LogEvent_Level_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_messages_2eproto__INCLUDED
