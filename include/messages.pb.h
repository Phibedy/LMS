// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef PROTOBUF_messages_2eproto__INCLUDED
#define PROTOBUF_messages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace lms {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_messages_2eproto();
void protobuf_AssignDesc_messages_2eproto();
void protobuf_ShutdownFile_messages_2eproto();

class Request;
class Request_Info;
class Request_Shutdown;
class Request_ListClients;
class Request_Run;
class Request_ListProcesses;
class Request_Attach;
class Request_Stop;
class Request_ModuleList;
class InfoResponse;
class ClientListResponse;
class ClientListResponse_Client;
class ProcessListResponse;
class ProcessListResponse_Process;
class LogEvent;

enum LogEvent_Level {
  LogEvent_Level_ALL = 0,
  LogEvent_Level_DEBUG = 1,
  LogEvent_Level_INFO = 2,
  LogEvent_Level_WARN = 3,
  LogEvent_Level_ERROR = 4,
  LogEvent_Level_OFF = 255
};
bool LogEvent_Level_IsValid(int value);
const LogEvent_Level LogEvent_Level_Level_MIN = LogEvent_Level_ALL;
const LogEvent_Level LogEvent_Level_Level_MAX = LogEvent_Level_OFF;
const int LogEvent_Level_Level_ARRAYSIZE = LogEvent_Level_Level_MAX + 1;

const ::google::protobuf::EnumDescriptor* LogEvent_Level_descriptor();
inline const ::std::string& LogEvent_Level_Name(LogEvent_Level value) {
  return ::google::protobuf::internal::NameOfEnum(
    LogEvent_Level_descriptor(), value);
}
inline bool LogEvent_Level_Parse(
    const ::std::string& name, LogEvent_Level* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogEvent_Level>(
    LogEvent_Level_descriptor(), name, value);
}
// ===================================================================

class Request_Info : public ::google::protobuf::Message {
 public:
  Request_Info();
  virtual ~Request_Info();

  Request_Info(const Request_Info& from);

  inline Request_Info& operator=(const Request_Info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_Info& default_instance();

  void Swap(Request_Info* other);

  // implements Message ----------------------------------------------

  Request_Info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_Info& from);
  void MergeFrom(const Request_Info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:lms.Request.Info)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_Info* default_instance_;
};
// -------------------------------------------------------------------

class Request_Shutdown : public ::google::protobuf::Message {
 public:
  Request_Shutdown();
  virtual ~Request_Shutdown();

  Request_Shutdown(const Request_Shutdown& from);

  inline Request_Shutdown& operator=(const Request_Shutdown& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_Shutdown& default_instance();

  void Swap(Request_Shutdown* other);

  // implements Message ----------------------------------------------

  Request_Shutdown* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_Shutdown& from);
  void MergeFrom(const Request_Shutdown& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:lms.Request.Shutdown)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_Shutdown* default_instance_;
};
// -------------------------------------------------------------------

class Request_ListClients : public ::google::protobuf::Message {
 public:
  Request_ListClients();
  virtual ~Request_ListClients();

  Request_ListClients(const Request_ListClients& from);

  inline Request_ListClients& operator=(const Request_ListClients& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_ListClients& default_instance();

  void Swap(Request_ListClients* other);

  // implements Message ----------------------------------------------

  Request_ListClients* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_ListClients& from);
  void MergeFrom(const Request_ListClients& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:lms.Request.ListClients)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_ListClients* default_instance_;
};
// -------------------------------------------------------------------

class Request_Run : public ::google::protobuf::Message {
 public:
  Request_Run();
  virtual ~Request_Run();

  Request_Run(const Request_Run& from);

  inline Request_Run& operator=(const Request_Run& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_Run& default_instance();

  void Swap(Request_Run* other);

  // implements Message ----------------------------------------------

  Request_Run* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_Run& from);
  void MergeFrom(const Request_Run& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string config_file = 1;
  inline bool has_config_file() const;
  inline void clear_config_file();
  static const int kConfigFileFieldNumber = 1;
  inline const ::std::string& config_file() const;
  inline void set_config_file(const ::std::string& value);
  inline void set_config_file(const char* value);
  inline void set_config_file(const char* value, size_t size);
  inline ::std::string* mutable_config_file();
  inline ::std::string* release_config_file();
  inline void set_allocated_config_file(::std::string* config_file);

  // repeated string include_paths = 2;
  inline int include_paths_size() const;
  inline void clear_include_paths();
  static const int kIncludePathsFieldNumber = 2;
  inline const ::std::string& include_paths(int index) const;
  inline ::std::string* mutable_include_paths(int index);
  inline void set_include_paths(int index, const ::std::string& value);
  inline void set_include_paths(int index, const char* value);
  inline void set_include_paths(int index, const char* value, size_t size);
  inline ::std::string* add_include_paths();
  inline void add_include_paths(const ::std::string& value);
  inline void add_include_paths(const char* value);
  inline void add_include_paths(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& include_paths() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_include_paths();

  // @@protoc_insertion_point(class_scope:lms.Request.Run)
 private:
  inline void set_has_config_file();
  inline void clear_has_config_file();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* config_file_;
  ::google::protobuf::RepeatedPtrField< ::std::string> include_paths_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_Run* default_instance_;
};
// -------------------------------------------------------------------

class Request_ListProcesses : public ::google::protobuf::Message {
 public:
  Request_ListProcesses();
  virtual ~Request_ListProcesses();

  Request_ListProcesses(const Request_ListProcesses& from);

  inline Request_ListProcesses& operator=(const Request_ListProcesses& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_ListProcesses& default_instance();

  void Swap(Request_ListProcesses* other);

  // implements Message ----------------------------------------------

  Request_ListProcesses* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_ListProcesses& from);
  void MergeFrom(const Request_ListProcesses& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:lms.Request.ListProcesses)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_ListProcesses* default_instance_;
};
// -------------------------------------------------------------------

class Request_Attach : public ::google::protobuf::Message {
 public:
  Request_Attach();
  virtual ~Request_Attach();

  Request_Attach(const Request_Attach& from);

  inline Request_Attach& operator=(const Request_Attach& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_Attach& default_instance();

  void Swap(Request_Attach* other);

  // implements Message ----------------------------------------------

  Request_Attach* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_Attach& from);
  void MergeFrom(const Request_Attach& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:lms.Request.Attach)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_Attach* default_instance_;
};
// -------------------------------------------------------------------

class Request_Stop : public ::google::protobuf::Message {
 public:
  Request_Stop();
  virtual ~Request_Stop();

  Request_Stop(const Request_Stop& from);

  inline Request_Stop& operator=(const Request_Stop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_Stop& default_instance();

  void Swap(Request_Stop* other);

  // implements Message ----------------------------------------------

  Request_Stop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_Stop& from);
  void MergeFrom(const Request_Stop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional bool kill = 2;
  inline bool has_kill() const;
  inline void clear_kill();
  static const int kKillFieldNumber = 2;
  inline bool kill() const;
  inline void set_kill(bool value);

  // @@protoc_insertion_point(class_scope:lms.Request.Stop)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_kill();
  inline void clear_has_kill();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  bool kill_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_Stop* default_instance_;
};
// -------------------------------------------------------------------

class Request_ModuleList : public ::google::protobuf::Message {
 public:
  Request_ModuleList();
  virtual ~Request_ModuleList();

  Request_ModuleList(const Request_ModuleList& from);

  inline Request_ModuleList& operator=(const Request_ModuleList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_ModuleList& default_instance();

  void Swap(Request_ModuleList* other);

  // implements Message ----------------------------------------------

  Request_ModuleList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_ModuleList& from);
  void MergeFrom(const Request_ModuleList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:lms.Request.ModuleList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request_ModuleList* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  enum ContentCase {
    kInfo = 1,
    kShutdown = 2,
    kListClients = 3,
    kRun = 4,
    kListProcesses = 5,
    kAttach = 6,
    kStop = 7,
    kModuleList = 8,
    CONTENT_NOT_SET = 0,
  };

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Request_Info Info;
  typedef Request_Shutdown Shutdown;
  typedef Request_ListClients ListClients;
  typedef Request_Run Run;
  typedef Request_ListProcesses ListProcesses;
  typedef Request_Attach Attach;
  typedef Request_Stop Stop;
  typedef Request_ModuleList ModuleList;

  // accessors -------------------------------------------------------

  // optional .lms.Request.Info info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::lms::Request_Info& info() const;
  inline ::lms::Request_Info* mutable_info();
  inline ::lms::Request_Info* release_info();
  inline void set_allocated_info(::lms::Request_Info* info);

  // optional .lms.Request.Shutdown shutdown = 2;
  inline bool has_shutdown() const;
  inline void clear_shutdown();
  static const int kShutdownFieldNumber = 2;
  inline const ::lms::Request_Shutdown& shutdown() const;
  inline ::lms::Request_Shutdown* mutable_shutdown();
  inline ::lms::Request_Shutdown* release_shutdown();
  inline void set_allocated_shutdown(::lms::Request_Shutdown* shutdown);

  // optional .lms.Request.ListClients list_clients = 3;
  inline bool has_list_clients() const;
  inline void clear_list_clients();
  static const int kListClientsFieldNumber = 3;
  inline const ::lms::Request_ListClients& list_clients() const;
  inline ::lms::Request_ListClients* mutable_list_clients();
  inline ::lms::Request_ListClients* release_list_clients();
  inline void set_allocated_list_clients(::lms::Request_ListClients* list_clients);

  // optional .lms.Request.Run run = 4;
  inline bool has_run() const;
  inline void clear_run();
  static const int kRunFieldNumber = 4;
  inline const ::lms::Request_Run& run() const;
  inline ::lms::Request_Run* mutable_run();
  inline ::lms::Request_Run* release_run();
  inline void set_allocated_run(::lms::Request_Run* run);

  // optional .lms.Request.ListProcesses list_processes = 5;
  inline bool has_list_processes() const;
  inline void clear_list_processes();
  static const int kListProcessesFieldNumber = 5;
  inline const ::lms::Request_ListProcesses& list_processes() const;
  inline ::lms::Request_ListProcesses* mutable_list_processes();
  inline ::lms::Request_ListProcesses* release_list_processes();
  inline void set_allocated_list_processes(::lms::Request_ListProcesses* list_processes);

  // optional .lms.Request.Attach attach = 6;
  inline bool has_attach() const;
  inline void clear_attach();
  static const int kAttachFieldNumber = 6;
  inline const ::lms::Request_Attach& attach() const;
  inline ::lms::Request_Attach* mutable_attach();
  inline ::lms::Request_Attach* release_attach();
  inline void set_allocated_attach(::lms::Request_Attach* attach);

  // optional .lms.Request.Stop stop = 7;
  inline bool has_stop() const;
  inline void clear_stop();
  static const int kStopFieldNumber = 7;
  inline const ::lms::Request_Stop& stop() const;
  inline ::lms::Request_Stop* mutable_stop();
  inline ::lms::Request_Stop* release_stop();
  inline void set_allocated_stop(::lms::Request_Stop* stop);

  // optional .lms.Request.ModuleList module_list = 8;
  inline bool has_module_list() const;
  inline void clear_module_list();
  static const int kModuleListFieldNumber = 8;
  inline const ::lms::Request_ModuleList& module_list() const;
  inline ::lms::Request_ModuleList* mutable_module_list();
  inline ::lms::Request_ModuleList* release_module_list();
  inline void set_allocated_module_list(::lms::Request_ModuleList* module_list);

  inline ContentCase content_case() const;
  // @@protoc_insertion_point(class_scope:lms.Request)
 private:
  inline void set_has_info();
  inline void set_has_shutdown();
  inline void set_has_list_clients();
  inline void set_has_run();
  inline void set_has_list_processes();
  inline void set_has_attach();
  inline void set_has_stop();
  inline void set_has_module_list();

  inline bool has_content();
  void clear_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union ContentUnion {
    ::lms::Request_Info* info_;
    ::lms::Request_Shutdown* shutdown_;
    ::lms::Request_ListClients* list_clients_;
    ::lms::Request_Run* run_;
    ::lms::Request_ListProcesses* list_processes_;
    ::lms::Request_Attach* attach_;
    ::lms::Request_Stop* stop_;
    ::lms::Request_ModuleList* module_list_;
  } content_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class InfoResponse : public ::google::protobuf::Message {
 public:
  InfoResponse();
  virtual ~InfoResponse();

  InfoResponse(const InfoResponse& from);

  inline InfoResponse& operator=(const InfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InfoResponse& default_instance();

  void Swap(InfoResponse* other);

  // implements Message ----------------------------------------------

  InfoResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InfoResponse& from);
  void MergeFrom(const InfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // optional int32 pid = 2;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 2;
  inline ::google::protobuf::int32 pid() const;
  inline void set_pid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:lms.InfoResponse)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_pid();
  inline void clear_has_pid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 version_;
  ::google::protobuf::int32 pid_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static InfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class ClientListResponse_Client : public ::google::protobuf::Message {
 public:
  ClientListResponse_Client();
  virtual ~ClientListResponse_Client();

  ClientListResponse_Client(const ClientListResponse_Client& from);

  inline ClientListResponse_Client& operator=(const ClientListResponse_Client& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientListResponse_Client& default_instance();

  void Swap(ClientListResponse_Client* other);

  // implements Message ----------------------------------------------

  ClientListResponse_Client* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientListResponse_Client& from);
  void MergeFrom(const ClientListResponse_Client& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 fd = 1;
  inline bool has_fd() const;
  inline void clear_fd();
  static const int kFdFieldNumber = 1;
  inline ::google::protobuf::int32 fd() const;
  inline void set_fd(::google::protobuf::int32 value);

  // optional string peer = 2;
  inline bool has_peer() const;
  inline void clear_peer();
  static const int kPeerFieldNumber = 2;
  inline const ::std::string& peer() const;
  inline void set_peer(const ::std::string& value);
  inline void set_peer(const char* value);
  inline void set_peer(const char* value, size_t size);
  inline ::std::string* mutable_peer();
  inline ::std::string* release_peer();
  inline void set_allocated_peer(::std::string* peer);

  // @@protoc_insertion_point(class_scope:lms.ClientListResponse.Client)
 private:
  inline void set_has_fd();
  inline void clear_has_fd();
  inline void set_has_peer();
  inline void clear_has_peer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* peer_;
  ::google::protobuf::int32 fd_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static ClientListResponse_Client* default_instance_;
};
// -------------------------------------------------------------------

class ClientListResponse : public ::google::protobuf::Message {
 public:
  ClientListResponse();
  virtual ~ClientListResponse();

  ClientListResponse(const ClientListResponse& from);

  inline ClientListResponse& operator=(const ClientListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientListResponse& default_instance();

  void Swap(ClientListResponse* other);

  // implements Message ----------------------------------------------

  ClientListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientListResponse& from);
  void MergeFrom(const ClientListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ClientListResponse_Client Client;

  // accessors -------------------------------------------------------

  // repeated .lms.ClientListResponse.Client clients = 1;
  inline int clients_size() const;
  inline void clear_clients();
  static const int kClientsFieldNumber = 1;
  inline const ::lms::ClientListResponse_Client& clients(int index) const;
  inline ::lms::ClientListResponse_Client* mutable_clients(int index);
  inline ::lms::ClientListResponse_Client* add_clients();
  inline const ::google::protobuf::RepeatedPtrField< ::lms::ClientListResponse_Client >&
      clients() const;
  inline ::google::protobuf::RepeatedPtrField< ::lms::ClientListResponse_Client >*
      mutable_clients();

  // @@protoc_insertion_point(class_scope:lms.ClientListResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::lms::ClientListResponse_Client > clients_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static ClientListResponse* default_instance_;
};
// -------------------------------------------------------------------

class ProcessListResponse_Process : public ::google::protobuf::Message {
 public:
  ProcessListResponse_Process();
  virtual ~ProcessListResponse_Process();

  ProcessListResponse_Process(const ProcessListResponse_Process& from);

  inline ProcessListResponse_Process& operator=(const ProcessListResponse_Process& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessListResponse_Process& default_instance();

  void Swap(ProcessListResponse_Process* other);

  // implements Message ----------------------------------------------

  ProcessListResponse_Process* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessListResponse_Process& from);
  void MergeFrom(const ProcessListResponse_Process& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 pid = 1;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 1;
  inline ::google::protobuf::int32 pid() const;
  inline void set_pid(::google::protobuf::int32 value);

  // optional string config_file = 2;
  inline bool has_config_file() const;
  inline void clear_config_file();
  static const int kConfigFileFieldNumber = 2;
  inline const ::std::string& config_file() const;
  inline void set_config_file(const ::std::string& value);
  inline void set_config_file(const char* value);
  inline void set_config_file(const char* value, size_t size);
  inline ::std::string* mutable_config_file();
  inline ::std::string* release_config_file();
  inline void set_allocated_config_file(::std::string* config_file);

  // @@protoc_insertion_point(class_scope:lms.ProcessListResponse.Process)
 private:
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_config_file();
  inline void clear_has_config_file();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* config_file_;
  ::google::protobuf::int32 pid_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static ProcessListResponse_Process* default_instance_;
};
// -------------------------------------------------------------------

class ProcessListResponse : public ::google::protobuf::Message {
 public:
  ProcessListResponse();
  virtual ~ProcessListResponse();

  ProcessListResponse(const ProcessListResponse& from);

  inline ProcessListResponse& operator=(const ProcessListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessListResponse& default_instance();

  void Swap(ProcessListResponse* other);

  // implements Message ----------------------------------------------

  ProcessListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessListResponse& from);
  void MergeFrom(const ProcessListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ProcessListResponse_Process Process;

  // accessors -------------------------------------------------------

  // repeated .lms.ProcessListResponse.Process processes = 1;
  inline int processes_size() const;
  inline void clear_processes();
  static const int kProcessesFieldNumber = 1;
  inline const ::lms::ProcessListResponse_Process& processes(int index) const;
  inline ::lms::ProcessListResponse_Process* mutable_processes(int index);
  inline ::lms::ProcessListResponse_Process* add_processes();
  inline const ::google::protobuf::RepeatedPtrField< ::lms::ProcessListResponse_Process >&
      processes() const;
  inline ::google::protobuf::RepeatedPtrField< ::lms::ProcessListResponse_Process >*
      mutable_processes();

  // @@protoc_insertion_point(class_scope:lms.ProcessListResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::lms::ProcessListResponse_Process > processes_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static ProcessListResponse* default_instance_;
};
// -------------------------------------------------------------------

class LogEvent : public ::google::protobuf::Message {
 public:
  LogEvent();
  virtual ~LogEvent();

  LogEvent(const LogEvent& from);

  inline LogEvent& operator=(const LogEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogEvent& default_instance();

  void Swap(LogEvent* other);

  // implements Message ----------------------------------------------

  LogEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogEvent& from);
  void MergeFrom(const LogEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LogEvent_Level Level;
  static const Level ALL = LogEvent_Level_ALL;
  static const Level DEBUG = LogEvent_Level_DEBUG;
  static const Level INFO = LogEvent_Level_INFO;
  static const Level WARN = LogEvent_Level_WARN;
  static const Level ERROR = LogEvent_Level_ERROR;
  static const Level OFF = LogEvent_Level_OFF;
  static inline bool Level_IsValid(int value) {
    return LogEvent_Level_IsValid(value);
  }
  static const Level Level_MIN =
    LogEvent_Level_Level_MIN;
  static const Level Level_MAX =
    LogEvent_Level_Level_MAX;
  static const int Level_ARRAYSIZE =
    LogEvent_Level_Level_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Level_descriptor() {
    return LogEvent_Level_descriptor();
  }
  static inline const ::std::string& Level_Name(Level value) {
    return LogEvent_Level_Name(value);
  }
  static inline bool Level_Parse(const ::std::string& name,
      Level* value) {
    return LogEvent_Level_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .lms.LogEvent.Level level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::lms::LogEvent_Level level() const;
  inline void set_level(::lms::LogEvent_Level value);

  // optional string tag = 2;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 2;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  inline void set_allocated_tag(::std::string* tag);

  // optional string text = 3;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 3;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:lms.LogEvent)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* tag_;
  ::std::string* text_;
  int level_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static LogEvent* default_instance_;
};
// ===================================================================


// ===================================================================

// Request_Info

// -------------------------------------------------------------------

// Request_Shutdown

// -------------------------------------------------------------------

// Request_ListClients

// -------------------------------------------------------------------

// Request_Run

// optional string config_file = 1;
inline bool Request_Run::has_config_file() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_Run::set_has_config_file() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_Run::clear_has_config_file() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_Run::clear_config_file() {
  if (config_file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_->clear();
  }
  clear_has_config_file();
}
inline const ::std::string& Request_Run::config_file() const {
  // @@protoc_insertion_point(field_get:lms.Request.Run.config_file)
  return *config_file_;
}
inline void Request_Run::set_config_file(const ::std::string& value) {
  set_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_ = new ::std::string;
  }
  config_file_->assign(value);
  // @@protoc_insertion_point(field_set:lms.Request.Run.config_file)
}
inline void Request_Run::set_config_file(const char* value) {
  set_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_ = new ::std::string;
  }
  config_file_->assign(value);
  // @@protoc_insertion_point(field_set_char:lms.Request.Run.config_file)
}
inline void Request_Run::set_config_file(const char* value, size_t size) {
  set_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_ = new ::std::string;
  }
  config_file_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:lms.Request.Run.config_file)
}
inline ::std::string* Request_Run::mutable_config_file() {
  set_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:lms.Request.Run.config_file)
  return config_file_;
}
inline ::std::string* Request_Run::release_config_file() {
  clear_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = config_file_;
    config_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Request_Run::set_allocated_config_file(::std::string* config_file) {
  if (config_file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete config_file_;
  }
  if (config_file) {
    set_has_config_file();
    config_file_ = config_file;
  } else {
    clear_has_config_file();
    config_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:lms.Request.Run.config_file)
}

// repeated string include_paths = 2;
inline int Request_Run::include_paths_size() const {
  return include_paths_.size();
}
inline void Request_Run::clear_include_paths() {
  include_paths_.Clear();
}
inline const ::std::string& Request_Run::include_paths(int index) const {
  // @@protoc_insertion_point(field_get:lms.Request.Run.include_paths)
  return include_paths_.Get(index);
}
inline ::std::string* Request_Run::mutable_include_paths(int index) {
  // @@protoc_insertion_point(field_mutable:lms.Request.Run.include_paths)
  return include_paths_.Mutable(index);
}
inline void Request_Run::set_include_paths(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:lms.Request.Run.include_paths)
  include_paths_.Mutable(index)->assign(value);
}
inline void Request_Run::set_include_paths(int index, const char* value) {
  include_paths_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:lms.Request.Run.include_paths)
}
inline void Request_Run::set_include_paths(int index, const char* value, size_t size) {
  include_paths_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:lms.Request.Run.include_paths)
}
inline ::std::string* Request_Run::add_include_paths() {
  return include_paths_.Add();
}
inline void Request_Run::add_include_paths(const ::std::string& value) {
  include_paths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:lms.Request.Run.include_paths)
}
inline void Request_Run::add_include_paths(const char* value) {
  include_paths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:lms.Request.Run.include_paths)
}
inline void Request_Run::add_include_paths(const char* value, size_t size) {
  include_paths_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:lms.Request.Run.include_paths)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Request_Run::include_paths() const {
  // @@protoc_insertion_point(field_list:lms.Request.Run.include_paths)
  return include_paths_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Request_Run::mutable_include_paths() {
  // @@protoc_insertion_point(field_mutable_list:lms.Request.Run.include_paths)
  return &include_paths_;
}

// -------------------------------------------------------------------

// Request_ListProcesses

// -------------------------------------------------------------------

// Request_Attach

// optional string id = 1;
inline bool Request_Attach::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_Attach::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_Attach::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_Attach::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Request_Attach::id() const {
  // @@protoc_insertion_point(field_get:lms.Request.Attach.id)
  return *id_;
}
inline void Request_Attach::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:lms.Request.Attach.id)
}
inline void Request_Attach::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:lms.Request.Attach.id)
}
inline void Request_Attach::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:lms.Request.Attach.id)
}
inline ::std::string* Request_Attach::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:lms.Request.Attach.id)
  return id_;
}
inline ::std::string* Request_Attach::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Request_Attach::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:lms.Request.Attach.id)
}

// -------------------------------------------------------------------

// Request_Stop

// optional string id = 1;
inline bool Request_Stop::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request_Stop::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request_Stop::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request_Stop::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Request_Stop::id() const {
  // @@protoc_insertion_point(field_get:lms.Request.Stop.id)
  return *id_;
}
inline void Request_Stop::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:lms.Request.Stop.id)
}
inline void Request_Stop::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:lms.Request.Stop.id)
}
inline void Request_Stop::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:lms.Request.Stop.id)
}
inline ::std::string* Request_Stop::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:lms.Request.Stop.id)
  return id_;
}
inline ::std::string* Request_Stop::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Request_Stop::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:lms.Request.Stop.id)
}

// optional bool kill = 2;
inline bool Request_Stop::has_kill() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request_Stop::set_has_kill() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request_Stop::clear_has_kill() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request_Stop::clear_kill() {
  kill_ = false;
  clear_has_kill();
}
inline bool Request_Stop::kill() const {
  // @@protoc_insertion_point(field_get:lms.Request.Stop.kill)
  return kill_;
}
inline void Request_Stop::set_kill(bool value) {
  set_has_kill();
  kill_ = value;
  // @@protoc_insertion_point(field_set:lms.Request.Stop.kill)
}

// -------------------------------------------------------------------

// Request_ModuleList

// -------------------------------------------------------------------

// Request

// optional .lms.Request.Info info = 1;
inline bool Request::has_info() const {
  return content_case() == kInfo;
}
inline void Request::set_has_info() {
  _oneof_case_[0] = kInfo;
}
inline void Request::clear_info() {
  if (has_info()) {
    delete content_.info_;
    clear_has_content();
  }
}
inline const ::lms::Request_Info& Request::info() const {
  return has_info() ? *content_.info_
                      : ::lms::Request_Info::default_instance();
}
inline ::lms::Request_Info* Request::mutable_info() {
  if (!has_info()) {
    clear_content();
    set_has_info();
    content_.info_ = new ::lms::Request_Info;
  }
  return content_.info_;
}
inline ::lms::Request_Info* Request::release_info() {
  if (has_info()) {
    clear_has_content();
    ::lms::Request_Info* temp = content_.info_;
    content_.info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_info(::lms::Request_Info* info) {
  clear_content();
  if (info) {
    set_has_info();
    content_.info_ = info;
  }
}

// optional .lms.Request.Shutdown shutdown = 2;
inline bool Request::has_shutdown() const {
  return content_case() == kShutdown;
}
inline void Request::set_has_shutdown() {
  _oneof_case_[0] = kShutdown;
}
inline void Request::clear_shutdown() {
  if (has_shutdown()) {
    delete content_.shutdown_;
    clear_has_content();
  }
}
inline const ::lms::Request_Shutdown& Request::shutdown() const {
  return has_shutdown() ? *content_.shutdown_
                      : ::lms::Request_Shutdown::default_instance();
}
inline ::lms::Request_Shutdown* Request::mutable_shutdown() {
  if (!has_shutdown()) {
    clear_content();
    set_has_shutdown();
    content_.shutdown_ = new ::lms::Request_Shutdown;
  }
  return content_.shutdown_;
}
inline ::lms::Request_Shutdown* Request::release_shutdown() {
  if (has_shutdown()) {
    clear_has_content();
    ::lms::Request_Shutdown* temp = content_.shutdown_;
    content_.shutdown_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_shutdown(::lms::Request_Shutdown* shutdown) {
  clear_content();
  if (shutdown) {
    set_has_shutdown();
    content_.shutdown_ = shutdown;
  }
}

// optional .lms.Request.ListClients list_clients = 3;
inline bool Request::has_list_clients() const {
  return content_case() == kListClients;
}
inline void Request::set_has_list_clients() {
  _oneof_case_[0] = kListClients;
}
inline void Request::clear_list_clients() {
  if (has_list_clients()) {
    delete content_.list_clients_;
    clear_has_content();
  }
}
inline const ::lms::Request_ListClients& Request::list_clients() const {
  return has_list_clients() ? *content_.list_clients_
                      : ::lms::Request_ListClients::default_instance();
}
inline ::lms::Request_ListClients* Request::mutable_list_clients() {
  if (!has_list_clients()) {
    clear_content();
    set_has_list_clients();
    content_.list_clients_ = new ::lms::Request_ListClients;
  }
  return content_.list_clients_;
}
inline ::lms::Request_ListClients* Request::release_list_clients() {
  if (has_list_clients()) {
    clear_has_content();
    ::lms::Request_ListClients* temp = content_.list_clients_;
    content_.list_clients_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_list_clients(::lms::Request_ListClients* list_clients) {
  clear_content();
  if (list_clients) {
    set_has_list_clients();
    content_.list_clients_ = list_clients;
  }
}

// optional .lms.Request.Run run = 4;
inline bool Request::has_run() const {
  return content_case() == kRun;
}
inline void Request::set_has_run() {
  _oneof_case_[0] = kRun;
}
inline void Request::clear_run() {
  if (has_run()) {
    delete content_.run_;
    clear_has_content();
  }
}
inline const ::lms::Request_Run& Request::run() const {
  return has_run() ? *content_.run_
                      : ::lms::Request_Run::default_instance();
}
inline ::lms::Request_Run* Request::mutable_run() {
  if (!has_run()) {
    clear_content();
    set_has_run();
    content_.run_ = new ::lms::Request_Run;
  }
  return content_.run_;
}
inline ::lms::Request_Run* Request::release_run() {
  if (has_run()) {
    clear_has_content();
    ::lms::Request_Run* temp = content_.run_;
    content_.run_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_run(::lms::Request_Run* run) {
  clear_content();
  if (run) {
    set_has_run();
    content_.run_ = run;
  }
}

// optional .lms.Request.ListProcesses list_processes = 5;
inline bool Request::has_list_processes() const {
  return content_case() == kListProcesses;
}
inline void Request::set_has_list_processes() {
  _oneof_case_[0] = kListProcesses;
}
inline void Request::clear_list_processes() {
  if (has_list_processes()) {
    delete content_.list_processes_;
    clear_has_content();
  }
}
inline const ::lms::Request_ListProcesses& Request::list_processes() const {
  return has_list_processes() ? *content_.list_processes_
                      : ::lms::Request_ListProcesses::default_instance();
}
inline ::lms::Request_ListProcesses* Request::mutable_list_processes() {
  if (!has_list_processes()) {
    clear_content();
    set_has_list_processes();
    content_.list_processes_ = new ::lms::Request_ListProcesses;
  }
  return content_.list_processes_;
}
inline ::lms::Request_ListProcesses* Request::release_list_processes() {
  if (has_list_processes()) {
    clear_has_content();
    ::lms::Request_ListProcesses* temp = content_.list_processes_;
    content_.list_processes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_list_processes(::lms::Request_ListProcesses* list_processes) {
  clear_content();
  if (list_processes) {
    set_has_list_processes();
    content_.list_processes_ = list_processes;
  }
}

// optional .lms.Request.Attach attach = 6;
inline bool Request::has_attach() const {
  return content_case() == kAttach;
}
inline void Request::set_has_attach() {
  _oneof_case_[0] = kAttach;
}
inline void Request::clear_attach() {
  if (has_attach()) {
    delete content_.attach_;
    clear_has_content();
  }
}
inline const ::lms::Request_Attach& Request::attach() const {
  return has_attach() ? *content_.attach_
                      : ::lms::Request_Attach::default_instance();
}
inline ::lms::Request_Attach* Request::mutable_attach() {
  if (!has_attach()) {
    clear_content();
    set_has_attach();
    content_.attach_ = new ::lms::Request_Attach;
  }
  return content_.attach_;
}
inline ::lms::Request_Attach* Request::release_attach() {
  if (has_attach()) {
    clear_has_content();
    ::lms::Request_Attach* temp = content_.attach_;
    content_.attach_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_attach(::lms::Request_Attach* attach) {
  clear_content();
  if (attach) {
    set_has_attach();
    content_.attach_ = attach;
  }
}

// optional .lms.Request.Stop stop = 7;
inline bool Request::has_stop() const {
  return content_case() == kStop;
}
inline void Request::set_has_stop() {
  _oneof_case_[0] = kStop;
}
inline void Request::clear_stop() {
  if (has_stop()) {
    delete content_.stop_;
    clear_has_content();
  }
}
inline const ::lms::Request_Stop& Request::stop() const {
  return has_stop() ? *content_.stop_
                      : ::lms::Request_Stop::default_instance();
}
inline ::lms::Request_Stop* Request::mutable_stop() {
  if (!has_stop()) {
    clear_content();
    set_has_stop();
    content_.stop_ = new ::lms::Request_Stop;
  }
  return content_.stop_;
}
inline ::lms::Request_Stop* Request::release_stop() {
  if (has_stop()) {
    clear_has_content();
    ::lms::Request_Stop* temp = content_.stop_;
    content_.stop_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_stop(::lms::Request_Stop* stop) {
  clear_content();
  if (stop) {
    set_has_stop();
    content_.stop_ = stop;
  }
}

// optional .lms.Request.ModuleList module_list = 8;
inline bool Request::has_module_list() const {
  return content_case() == kModuleList;
}
inline void Request::set_has_module_list() {
  _oneof_case_[0] = kModuleList;
}
inline void Request::clear_module_list() {
  if (has_module_list()) {
    delete content_.module_list_;
    clear_has_content();
  }
}
inline const ::lms::Request_ModuleList& Request::module_list() const {
  return has_module_list() ? *content_.module_list_
                      : ::lms::Request_ModuleList::default_instance();
}
inline ::lms::Request_ModuleList* Request::mutable_module_list() {
  if (!has_module_list()) {
    clear_content();
    set_has_module_list();
    content_.module_list_ = new ::lms::Request_ModuleList;
  }
  return content_.module_list_;
}
inline ::lms::Request_ModuleList* Request::release_module_list() {
  if (has_module_list()) {
    clear_has_content();
    ::lms::Request_ModuleList* temp = content_.module_list_;
    content_.module_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_module_list(::lms::Request_ModuleList* module_list) {
  clear_content();
  if (module_list) {
    set_has_module_list();
    content_.module_list_ = module_list;
  }
}

inline bool Request::has_content() {
  return content_case() != CONTENT_NOT_SET;
}
inline void Request::clear_has_content() {
  _oneof_case_[0] = CONTENT_NOT_SET;
}
inline Request::ContentCase Request::content_case() const {
  return Request::ContentCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// InfoResponse

// optional int32 version = 1;
inline bool InfoResponse::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InfoResponse::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InfoResponse::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InfoResponse::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 InfoResponse::version() const {
  // @@protoc_insertion_point(field_get:lms.InfoResponse.version)
  return version_;
}
inline void InfoResponse::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:lms.InfoResponse.version)
}

// optional int32 pid = 2;
inline bool InfoResponse::has_pid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InfoResponse::set_has_pid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InfoResponse::clear_has_pid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InfoResponse::clear_pid() {
  pid_ = 0;
  clear_has_pid();
}
inline ::google::protobuf::int32 InfoResponse::pid() const {
  // @@protoc_insertion_point(field_get:lms.InfoResponse.pid)
  return pid_;
}
inline void InfoResponse::set_pid(::google::protobuf::int32 value) {
  set_has_pid();
  pid_ = value;
  // @@protoc_insertion_point(field_set:lms.InfoResponse.pid)
}

// -------------------------------------------------------------------

// ClientListResponse_Client

// optional int32 fd = 1;
inline bool ClientListResponse_Client::has_fd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientListResponse_Client::set_has_fd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientListResponse_Client::clear_has_fd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientListResponse_Client::clear_fd() {
  fd_ = 0;
  clear_has_fd();
}
inline ::google::protobuf::int32 ClientListResponse_Client::fd() const {
  // @@protoc_insertion_point(field_get:lms.ClientListResponse.Client.fd)
  return fd_;
}
inline void ClientListResponse_Client::set_fd(::google::protobuf::int32 value) {
  set_has_fd();
  fd_ = value;
  // @@protoc_insertion_point(field_set:lms.ClientListResponse.Client.fd)
}

// optional string peer = 2;
inline bool ClientListResponse_Client::has_peer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientListResponse_Client::set_has_peer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientListResponse_Client::clear_has_peer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientListResponse_Client::clear_peer() {
  if (peer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    peer_->clear();
  }
  clear_has_peer();
}
inline const ::std::string& ClientListResponse_Client::peer() const {
  // @@protoc_insertion_point(field_get:lms.ClientListResponse.Client.peer)
  return *peer_;
}
inline void ClientListResponse_Client::set_peer(const ::std::string& value) {
  set_has_peer();
  if (peer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    peer_ = new ::std::string;
  }
  peer_->assign(value);
  // @@protoc_insertion_point(field_set:lms.ClientListResponse.Client.peer)
}
inline void ClientListResponse_Client::set_peer(const char* value) {
  set_has_peer();
  if (peer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    peer_ = new ::std::string;
  }
  peer_->assign(value);
  // @@protoc_insertion_point(field_set_char:lms.ClientListResponse.Client.peer)
}
inline void ClientListResponse_Client::set_peer(const char* value, size_t size) {
  set_has_peer();
  if (peer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    peer_ = new ::std::string;
  }
  peer_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:lms.ClientListResponse.Client.peer)
}
inline ::std::string* ClientListResponse_Client::mutable_peer() {
  set_has_peer();
  if (peer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    peer_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:lms.ClientListResponse.Client.peer)
  return peer_;
}
inline ::std::string* ClientListResponse_Client::release_peer() {
  clear_has_peer();
  if (peer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = peer_;
    peer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClientListResponse_Client::set_allocated_peer(::std::string* peer) {
  if (peer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete peer_;
  }
  if (peer) {
    set_has_peer();
    peer_ = peer;
  } else {
    clear_has_peer();
    peer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:lms.ClientListResponse.Client.peer)
}

// -------------------------------------------------------------------

// ClientListResponse

// repeated .lms.ClientListResponse.Client clients = 1;
inline int ClientListResponse::clients_size() const {
  return clients_.size();
}
inline void ClientListResponse::clear_clients() {
  clients_.Clear();
}
inline const ::lms::ClientListResponse_Client& ClientListResponse::clients(int index) const {
  // @@protoc_insertion_point(field_get:lms.ClientListResponse.clients)
  return clients_.Get(index);
}
inline ::lms::ClientListResponse_Client* ClientListResponse::mutable_clients(int index) {
  // @@protoc_insertion_point(field_mutable:lms.ClientListResponse.clients)
  return clients_.Mutable(index);
}
inline ::lms::ClientListResponse_Client* ClientListResponse::add_clients() {
  // @@protoc_insertion_point(field_add:lms.ClientListResponse.clients)
  return clients_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lms::ClientListResponse_Client >&
ClientListResponse::clients() const {
  // @@protoc_insertion_point(field_list:lms.ClientListResponse.clients)
  return clients_;
}
inline ::google::protobuf::RepeatedPtrField< ::lms::ClientListResponse_Client >*
ClientListResponse::mutable_clients() {
  // @@protoc_insertion_point(field_mutable_list:lms.ClientListResponse.clients)
  return &clients_;
}

// -------------------------------------------------------------------

// ProcessListResponse_Process

// optional int32 pid = 1;
inline bool ProcessListResponse_Process::has_pid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProcessListResponse_Process::set_has_pid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProcessListResponse_Process::clear_has_pid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProcessListResponse_Process::clear_pid() {
  pid_ = 0;
  clear_has_pid();
}
inline ::google::protobuf::int32 ProcessListResponse_Process::pid() const {
  // @@protoc_insertion_point(field_get:lms.ProcessListResponse.Process.pid)
  return pid_;
}
inline void ProcessListResponse_Process::set_pid(::google::protobuf::int32 value) {
  set_has_pid();
  pid_ = value;
  // @@protoc_insertion_point(field_set:lms.ProcessListResponse.Process.pid)
}

// optional string config_file = 2;
inline bool ProcessListResponse_Process::has_config_file() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcessListResponse_Process::set_has_config_file() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcessListResponse_Process::clear_has_config_file() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcessListResponse_Process::clear_config_file() {
  if (config_file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_->clear();
  }
  clear_has_config_file();
}
inline const ::std::string& ProcessListResponse_Process::config_file() const {
  // @@protoc_insertion_point(field_get:lms.ProcessListResponse.Process.config_file)
  return *config_file_;
}
inline void ProcessListResponse_Process::set_config_file(const ::std::string& value) {
  set_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_ = new ::std::string;
  }
  config_file_->assign(value);
  // @@protoc_insertion_point(field_set:lms.ProcessListResponse.Process.config_file)
}
inline void ProcessListResponse_Process::set_config_file(const char* value) {
  set_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_ = new ::std::string;
  }
  config_file_->assign(value);
  // @@protoc_insertion_point(field_set_char:lms.ProcessListResponse.Process.config_file)
}
inline void ProcessListResponse_Process::set_config_file(const char* value, size_t size) {
  set_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_ = new ::std::string;
  }
  config_file_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:lms.ProcessListResponse.Process.config_file)
}
inline ::std::string* ProcessListResponse_Process::mutable_config_file() {
  set_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    config_file_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:lms.ProcessListResponse.Process.config_file)
  return config_file_;
}
inline ::std::string* ProcessListResponse_Process::release_config_file() {
  clear_has_config_file();
  if (config_file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = config_file_;
    config_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ProcessListResponse_Process::set_allocated_config_file(::std::string* config_file) {
  if (config_file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete config_file_;
  }
  if (config_file) {
    set_has_config_file();
    config_file_ = config_file;
  } else {
    clear_has_config_file();
    config_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:lms.ProcessListResponse.Process.config_file)
}

// -------------------------------------------------------------------

// ProcessListResponse

// repeated .lms.ProcessListResponse.Process processes = 1;
inline int ProcessListResponse::processes_size() const {
  return processes_.size();
}
inline void ProcessListResponse::clear_processes() {
  processes_.Clear();
}
inline const ::lms::ProcessListResponse_Process& ProcessListResponse::processes(int index) const {
  // @@protoc_insertion_point(field_get:lms.ProcessListResponse.processes)
  return processes_.Get(index);
}
inline ::lms::ProcessListResponse_Process* ProcessListResponse::mutable_processes(int index) {
  // @@protoc_insertion_point(field_mutable:lms.ProcessListResponse.processes)
  return processes_.Mutable(index);
}
inline ::lms::ProcessListResponse_Process* ProcessListResponse::add_processes() {
  // @@protoc_insertion_point(field_add:lms.ProcessListResponse.processes)
  return processes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lms::ProcessListResponse_Process >&
ProcessListResponse::processes() const {
  // @@protoc_insertion_point(field_list:lms.ProcessListResponse.processes)
  return processes_;
}
inline ::google::protobuf::RepeatedPtrField< ::lms::ProcessListResponse_Process >*
ProcessListResponse::mutable_processes() {
  // @@protoc_insertion_point(field_mutable_list:lms.ProcessListResponse.processes)
  return &processes_;
}

// -------------------------------------------------------------------

// LogEvent

// optional .lms.LogEvent.Level level = 1;
inline bool LogEvent::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogEvent::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogEvent::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogEvent::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::lms::LogEvent_Level LogEvent::level() const {
  // @@protoc_insertion_point(field_get:lms.LogEvent.level)
  return static_cast< ::lms::LogEvent_Level >(level_);
}
inline void LogEvent::set_level(::lms::LogEvent_Level value) {
  assert(::lms::LogEvent_Level_IsValid(value));
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:lms.LogEvent.level)
}

// optional string tag = 2;
inline bool LogEvent::has_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogEvent::set_has_tag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogEvent::clear_has_tag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogEvent::clear_tag() {
  if (tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& LogEvent::tag() const {
  // @@protoc_insertion_point(field_get:lms.LogEvent.tag)
  return *tag_;
}
inline void LogEvent::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
  // @@protoc_insertion_point(field_set:lms.LogEvent.tag)
}
inline void LogEvent::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
  // @@protoc_insertion_point(field_set_char:lms.LogEvent.tag)
}
inline void LogEvent::set_tag(const char* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:lms.LogEvent.tag)
}
inline ::std::string* LogEvent::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:lms.LogEvent.tag)
  return tag_;
}
inline ::std::string* LogEvent::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LogEvent::set_allocated_tag(::std::string* tag) {
  if (tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tag_;
  }
  if (tag) {
    set_has_tag();
    tag_ = tag;
  } else {
    clear_has_tag();
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:lms.LogEvent.tag)
}

// optional string text = 3;
inline bool LogEvent::has_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogEvent::set_has_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogEvent::clear_has_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogEvent::clear_text() {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& LogEvent::text() const {
  // @@protoc_insertion_point(field_get:lms.LogEvent.text)
  return *text_;
}
inline void LogEvent::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set:lms.LogEvent.text)
}
inline void LogEvent::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set_char:lms.LogEvent.text)
}
inline void LogEvent::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:lms.LogEvent.text)
}
inline ::std::string* LogEvent::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:lms.LogEvent.text)
  return text_;
}
inline ::std::string* LogEvent::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LogEvent::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:lms.LogEvent.text)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace lms

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::lms::LogEvent_Level> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lms::LogEvent_Level>() {
  return ::lms::LogEvent_Level_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_messages_2eproto__INCLUDED
